// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: api_keys.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createAPIKey = `-- name: CreateAPIKey :one
INSERT INTO api_keys (
    tenant_id,
    prefix,
    secret_hash,
    name,
    scopes_json,
    quota_json,
    kind,
    owner_user_id
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING id, tenant_id, prefix, secret_hash, name, scopes_json, quota_json, kind, owner_user_id, created_at, revoked_at, last_used_at
`

type CreateAPIKeyParams struct {
	TenantID    pgtype.UUID `json:"tenant_id"`
	Prefix      string      `json:"prefix"`
	SecretHash  string      `json:"secret_hash"`
	Name        string      `json:"name"`
	ScopesJson  []byte      `json:"scopes_json"`
	QuotaJson   []byte      `json:"quota_json"`
	Kind        ApiKeyKind  `json:"kind"`
	OwnerUserID pgtype.UUID `json:"owner_user_id"`
}

func (q *Queries) CreateAPIKey(ctx context.Context, arg CreateAPIKeyParams) (ApiKey, error) {
	row := q.db.QueryRow(ctx, createAPIKey,
		arg.TenantID,
		arg.Prefix,
		arg.SecretHash,
		arg.Name,
		arg.ScopesJson,
		arg.QuotaJson,
		arg.Kind,
		arg.OwnerUserID,
	)
	var i ApiKey
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Prefix,
		&i.SecretHash,
		&i.Name,
		&i.ScopesJson,
		&i.QuotaJson,
		&i.Kind,
		&i.OwnerUserID,
		&i.CreatedAt,
		&i.RevokedAt,
		&i.LastUsedAt,
	)
	return i, err
}

const getAPIKeyByID = `-- name: GetAPIKeyByID :one
SELECT id, tenant_id, prefix, secret_hash, name, scopes_json, quota_json, kind, owner_user_id, created_at, revoked_at, last_used_at
FROM api_keys
WHERE id = $1
`

func (q *Queries) GetAPIKeyByID(ctx context.Context, id pgtype.UUID) (ApiKey, error) {
	row := q.db.QueryRow(ctx, getAPIKeyByID, id)
	var i ApiKey
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Prefix,
		&i.SecretHash,
		&i.Name,
		&i.ScopesJson,
		&i.QuotaJson,
		&i.Kind,
		&i.OwnerUserID,
		&i.CreatedAt,
		&i.RevokedAt,
		&i.LastUsedAt,
	)
	return i, err
}

const getAPIKeyByPrefix = `-- name: GetAPIKeyByPrefix :one
SELECT id, tenant_id, prefix, secret_hash, name, scopes_json, quota_json, kind, owner_user_id, created_at, revoked_at, last_used_at
FROM api_keys
WHERE prefix = $1
`

func (q *Queries) GetAPIKeyByPrefix(ctx context.Context, prefix string) (ApiKey, error) {
	row := q.db.QueryRow(ctx, getAPIKeyByPrefix, prefix)
	var i ApiKey
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Prefix,
		&i.SecretHash,
		&i.Name,
		&i.ScopesJson,
		&i.QuotaJson,
		&i.Kind,
		&i.OwnerUserID,
		&i.CreatedAt,
		&i.RevokedAt,
		&i.LastUsedAt,
	)
	return i, err
}

const listAPIKeysByIDs = `-- name: ListAPIKeysByIDs :many
SELECT id, tenant_id, prefix, secret_hash, name, scopes_json, quota_json, kind, owner_user_id, created_at, revoked_at, last_used_at
FROM api_keys
WHERE id = ANY($1::uuid[])
`

func (q *Queries) ListAPIKeysByIDs(ctx context.Context, dollar_1 []pgtype.UUID) ([]ApiKey, error) {
	rows, err := q.db.Query(ctx, listAPIKeysByIDs, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ApiKey{}
	for rows.Next() {
		var i ApiKey
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Prefix,
			&i.SecretHash,
			&i.Name,
			&i.ScopesJson,
			&i.QuotaJson,
			&i.Kind,
			&i.OwnerUserID,
			&i.CreatedAt,
			&i.RevokedAt,
			&i.LastUsedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAPIKeysByOwnerAndTenant = `-- name: ListAPIKeysByOwnerAndTenant :many
SELECT id, tenant_id, prefix, secret_hash, name, scopes_json, quota_json, kind, owner_user_id, created_at, revoked_at, last_used_at
FROM api_keys
WHERE owner_user_id = $1
  AND tenant_id = $2
ORDER BY created_at DESC
`

type ListAPIKeysByOwnerAndTenantParams struct {
	OwnerUserID pgtype.UUID `json:"owner_user_id"`
	TenantID    pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) ListAPIKeysByOwnerAndTenant(ctx context.Context, arg ListAPIKeysByOwnerAndTenantParams) ([]ApiKey, error) {
	rows, err := q.db.Query(ctx, listAPIKeysByOwnerAndTenant, arg.OwnerUserID, arg.TenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ApiKey{}
	for rows.Next() {
		var i ApiKey
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Prefix,
			&i.SecretHash,
			&i.Name,
			&i.ScopesJson,
			&i.QuotaJson,
			&i.Kind,
			&i.OwnerUserID,
			&i.CreatedAt,
			&i.RevokedAt,
			&i.LastUsedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAPIKeysByTenant = `-- name: ListAPIKeysByTenant :many
SELECT id, tenant_id, prefix, secret_hash, name, scopes_json, quota_json, kind, owner_user_id, created_at, revoked_at, last_used_at
FROM api_keys
WHERE tenant_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListAPIKeysByTenant(ctx context.Context, tenantID pgtype.UUID) ([]ApiKey, error) {
	rows, err := q.db.Query(ctx, listAPIKeysByTenant, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ApiKey{}
	for rows.Next() {
		var i ApiKey
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Prefix,
			&i.SecretHash,
			&i.Name,
			&i.ScopesJson,
			&i.QuotaJson,
			&i.Kind,
			&i.OwnerUserID,
			&i.CreatedAt,
			&i.RevokedAt,
			&i.LastUsedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAllAPIKeys = `-- name: ListAllAPIKeys :many
SELECT
    k.id,
    k.tenant_id,
    t.name AS tenant_name,
    t.kind AS tenant_kind,
    k.prefix,
    k.name,
    k.scopes_json,
    k.quota_json,
    k.kind,
    k.owner_user_id,
    k.created_at,
    k.revoked_at,
    k.last_used_at,
    u.email AS owner_email,
    u.name AS owner_name
FROM api_keys k
JOIN tenants t ON t.id = k.tenant_id
LEFT JOIN users u ON u.id = k.owner_user_id
ORDER BY k.created_at DESC
`

type ListAllAPIKeysRow struct {
	ID          pgtype.UUID        `json:"id"`
	TenantID    pgtype.UUID        `json:"tenant_id"`
	TenantName  string             `json:"tenant_name"`
	TenantKind  TenantKind         `json:"tenant_kind"`
	Prefix      string             `json:"prefix"`
	Name        string             `json:"name"`
	ScopesJson  []byte             `json:"scopes_json"`
	QuotaJson   []byte             `json:"quota_json"`
	Kind        ApiKeyKind         `json:"kind"`
	OwnerUserID pgtype.UUID        `json:"owner_user_id"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	RevokedAt   pgtype.Timestamptz `json:"revoked_at"`
	LastUsedAt  pgtype.Timestamptz `json:"last_used_at"`
	OwnerEmail  pgtype.Text        `json:"owner_email"`
	OwnerName   pgtype.Text        `json:"owner_name"`
}

func (q *Queries) ListAllAPIKeys(ctx context.Context) ([]ListAllAPIKeysRow, error) {
	rows, err := q.db.Query(ctx, listAllAPIKeys)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListAllAPIKeysRow{}
	for rows.Next() {
		var i ListAllAPIKeysRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.TenantName,
			&i.TenantKind,
			&i.Prefix,
			&i.Name,
			&i.ScopesJson,
			&i.QuotaJson,
			&i.Kind,
			&i.OwnerUserID,
			&i.CreatedAt,
			&i.RevokedAt,
			&i.LastUsedAt,
			&i.OwnerEmail,
			&i.OwnerName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPersonalAPIKeysByUser = `-- name: ListPersonalAPIKeysByUser :many
SELECT id, tenant_id, prefix, secret_hash, name, scopes_json, quota_json, kind, owner_user_id, created_at, revoked_at, last_used_at
FROM api_keys
WHERE owner_user_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListPersonalAPIKeysByUser(ctx context.Context, ownerUserID pgtype.UUID) ([]ApiKey, error) {
	rows, err := q.db.Query(ctx, listPersonalAPIKeysByUser, ownerUserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ApiKey{}
	for rows.Next() {
		var i ApiKey
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Prefix,
			&i.SecretHash,
			&i.Name,
			&i.ScopesJson,
			&i.QuotaJson,
			&i.Kind,
			&i.OwnerUserID,
			&i.CreatedAt,
			&i.RevokedAt,
			&i.LastUsedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const revokeAPIKey = `-- name: RevokeAPIKey :one
UPDATE api_keys
SET revoked_at = NOW()
WHERE id = $1 AND revoked_at IS NULL
RETURNING id, tenant_id, prefix, secret_hash, name, scopes_json, quota_json, kind, owner_user_id, created_at, revoked_at, last_used_at
`

func (q *Queries) RevokeAPIKey(ctx context.Context, id pgtype.UUID) (ApiKey, error) {
	row := q.db.QueryRow(ctx, revokeAPIKey, id)
	var i ApiKey
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Prefix,
		&i.SecretHash,
		&i.Name,
		&i.ScopesJson,
		&i.QuotaJson,
		&i.Kind,
		&i.OwnerUserID,
		&i.CreatedAt,
		&i.RevokedAt,
		&i.LastUsedAt,
	)
	return i, err
}

const updateAPIKeyLastUsed = `-- name: UpdateAPIKeyLastUsed :exec
UPDATE api_keys
SET last_used_at = NOW()
WHERE id = $1
`

func (q *Queries) UpdateAPIKeyLastUsed(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, updateAPIKeyLastUsed, id)
	return err
}

const updateAPIKeyTenant = `-- name: UpdateAPIKeyTenant :one
UPDATE api_keys
SET tenant_id = $2
WHERE id = $1
RETURNING id, tenant_id, prefix, secret_hash, name, scopes_json, quota_json, kind, owner_user_id, created_at, revoked_at, last_used_at
`

type UpdateAPIKeyTenantParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) UpdateAPIKeyTenant(ctx context.Context, arg UpdateAPIKeyTenantParams) (ApiKey, error) {
	row := q.db.QueryRow(ctx, updateAPIKeyTenant, arg.ID, arg.TenantID)
	var i ApiKey
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Prefix,
		&i.SecretHash,
		&i.Name,
		&i.ScopesJson,
		&i.QuotaJson,
		&i.Kind,
		&i.OwnerUserID,
		&i.CreatedAt,
		&i.RevokedAt,
		&i.LastUsedAt,
	)
	return i, err
}
