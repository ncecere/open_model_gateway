// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: files.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createFile = `-- name: CreateFile :one
INSERT INTO files (
    tenant_id,
    filename,
    purpose,
    content_type,
    bytes,
    storage_backend,
    storage_key,
    checksum,
    encrypted,
    expires_at,
    status,
    status_updated_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, NOW()
) RETURNING id, tenant_id, filename, purpose, content_type, bytes, storage_backend, storage_key, checksum, encrypted, metadata, expires_at, created_at, deleted_at, status, status_details, status_updated_at
`

type CreateFileParams struct {
	TenantID       pgtype.UUID        `json:"tenant_id"`
	Filename       string             `json:"filename"`
	Purpose        string             `json:"purpose"`
	ContentType    string             `json:"content_type"`
	Bytes          int64              `json:"bytes"`
	StorageBackend string             `json:"storage_backend"`
	StorageKey     string             `json:"storage_key"`
	Checksum       pgtype.Text        `json:"checksum"`
	Encrypted      bool               `json:"encrypted"`
	ExpiresAt      pgtype.Timestamptz `json:"expires_at"`
	Status         string             `json:"status"`
}

func (q *Queries) CreateFile(ctx context.Context, arg CreateFileParams) (File, error) {
	row := q.db.QueryRow(ctx, createFile,
		arg.TenantID,
		arg.Filename,
		arg.Purpose,
		arg.ContentType,
		arg.Bytes,
		arg.StorageBackend,
		arg.StorageKey,
		arg.Checksum,
		arg.Encrypted,
		arg.ExpiresAt,
		arg.Status,
	)
	var i File
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Filename,
		&i.Purpose,
		&i.ContentType,
		&i.Bytes,
		&i.StorageBackend,
		&i.StorageKey,
		&i.Checksum,
		&i.Encrypted,
		&i.Metadata,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.DeletedAt,
		&i.Status,
		&i.StatusDetails,
		&i.StatusUpdatedAt,
	)
	return i, err
}

const deleteFile = `-- name: DeleteFile :exec
UPDATE files
SET deleted_at = NOW(),
    status = 'deleted',
    status_details = $3::text,
    status_updated_at = NOW()
WHERE tenant_id = $1 AND id = $2 AND deleted_at IS NULL
`

type DeleteFileParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	ID       pgtype.UUID `json:"id"`
	Reason   pgtype.Text `json:"reason"`
}

func (q *Queries) DeleteFile(ctx context.Context, arg DeleteFileParams) error {
	_, err := q.db.Exec(ctx, deleteFile, arg.TenantID, arg.ID, arg.Reason)
	return err
}

const getFile = `-- name: GetFile :one
SELECT id, tenant_id, filename, purpose, content_type, bytes, storage_backend, storage_key, checksum, encrypted, metadata, expires_at, created_at, deleted_at, status, status_details, status_updated_at
FROM files
WHERE tenant_id = $1 AND id = $2 AND deleted_at IS NULL
`

type GetFileParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	ID       pgtype.UUID `json:"id"`
}

func (q *Queries) GetFile(ctx context.Context, arg GetFileParams) (File, error) {
	row := q.db.QueryRow(ctx, getFile, arg.TenantID, arg.ID)
	var i File
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Filename,
		&i.Purpose,
		&i.ContentType,
		&i.Bytes,
		&i.StorageBackend,
		&i.StorageKey,
		&i.Checksum,
		&i.Encrypted,
		&i.Metadata,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.DeletedAt,
		&i.Status,
		&i.StatusDetails,
		&i.StatusUpdatedAt,
	)
	return i, err
}

const getFileByID = `-- name: GetFileByID :one
SELECT id, tenant_id, filename, purpose, content_type, bytes, storage_backend, storage_key, checksum, encrypted, metadata, expires_at, created_at, deleted_at, status, status_details, status_updated_at
FROM files
WHERE id = $1
`

func (q *Queries) GetFileByID(ctx context.Context, id pgtype.UUID) (File, error) {
	row := q.db.QueryRow(ctx, getFileByID, id)
	var i File
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Filename,
		&i.Purpose,
		&i.ContentType,
		&i.Bytes,
		&i.StorageBackend,
		&i.StorageKey,
		&i.Checksum,
		&i.Encrypted,
		&i.Metadata,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.DeletedAt,
		&i.Status,
		&i.StatusDetails,
		&i.StatusUpdatedAt,
	)
	return i, err
}

const listExpiredFiles = `-- name: ListExpiredFiles :many
SELECT id, tenant_id, filename, purpose, content_type, bytes, storage_backend, storage_key, checksum, encrypted, metadata, expires_at, created_at, deleted_at, status, status_details, status_updated_at
FROM files
WHERE deleted_at IS NULL AND expires_at <= $1
LIMIT $2
`

type ListExpiredFilesParams struct {
	ExpiresAt pgtype.Timestamptz `json:"expires_at"`
	Limit     int32              `json:"limit"`
}

func (q *Queries) ListExpiredFiles(ctx context.Context, arg ListExpiredFilesParams) ([]File, error) {
	rows, err := q.db.Query(ctx, listExpiredFiles, arg.ExpiresAt, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []File{}
	for rows.Next() {
		var i File
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Filename,
			&i.Purpose,
			&i.ContentType,
			&i.Bytes,
			&i.StorageBackend,
			&i.StorageKey,
			&i.Checksum,
			&i.Encrypted,
			&i.Metadata,
			&i.ExpiresAt,
			&i.CreatedAt,
			&i.DeletedAt,
			&i.Status,
			&i.StatusDetails,
			&i.StatusUpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFiles = `-- name: ListFiles :many
SELECT id, tenant_id, filename, purpose, content_type, bytes, storage_backend, storage_key, checksum, encrypted, metadata, expires_at, created_at, deleted_at, status, status_details, status_updated_at
FROM files
WHERE tenant_id = $1
  AND deleted_at IS NULL
  AND ($3::text IS NULL OR purpose = $3::text)
  AND (
    $4::timestamptz IS NULL
    OR created_at < $4::timestamptz
    OR (
      created_at = $4::timestamptz
      AND ($5::uuid IS NULL OR id < $5::uuid)
    )
  )
ORDER BY created_at DESC, id DESC
LIMIT $2
`

type ListFilesParams struct {
	TenantID       pgtype.UUID        `json:"tenant_id"`
	Limit          int32              `json:"limit"`
	Purpose        pgtype.Text        `json:"purpose"`
	AfterCreatedAt pgtype.Timestamptz `json:"after_created_at"`
	AfterID        pgtype.UUID        `json:"after_id"`
}

func (q *Queries) ListFiles(ctx context.Context, arg ListFilesParams) ([]File, error) {
	rows, err := q.db.Query(ctx, listFiles,
		arg.TenantID,
		arg.Limit,
		arg.Purpose,
		arg.AfterCreatedAt,
		arg.AfterID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []File{}
	for rows.Next() {
		var i File
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Filename,
			&i.Purpose,
			&i.ContentType,
			&i.Bytes,
			&i.StorageBackend,
			&i.StorageKey,
			&i.Checksum,
			&i.Encrypted,
			&i.Metadata,
			&i.ExpiresAt,
			&i.CreatedAt,
			&i.DeletedAt,
			&i.Status,
			&i.StatusDetails,
			&i.StatusUpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFilesAdmin = `-- name: ListFilesAdmin :many
SELECT f.id, f.tenant_id, f.filename, f.purpose, f.content_type, f.bytes, f.storage_backend, f.storage_key, f.checksum, f.encrypted, f.metadata, f.expires_at, f.created_at, f.deleted_at, f.status, f.status_details, f.status_updated_at, t.name AS tenant_name, COUNT(*) OVER() AS total_count
FROM files f
JOIN tenants t ON t.id = f.tenant_id
WHERE ($1::uuid IS NULL OR f.tenant_id = $1)
  AND ($2::text IS NULL OR f.purpose = $2::text)
  AND (
    $3::text IS NULL
    OR f.filename ILIKE '%' || $3::text || '%'
    OR t.name ILIKE '%' || $3::text || '%'
    OR f.id::text ILIKE '%' || $3::text || '%'
  )
  AND (
    $4::text = 'all'
    OR ($4::text = 'deleted' AND f.deleted_at IS NOT NULL)
    OR ($4::text = 'active' AND f.deleted_at IS NULL)
  )
ORDER BY f.created_at DESC
LIMIT $6 OFFSET $5
`

type ListFilesAdminParams struct {
	TenantID   pgtype.UUID `json:"tenant_id"`
	Purpose    pgtype.Text `json:"purpose"`
	Search     pgtype.Text `json:"search"`
	State      string      `json:"state"`
	PageOffset int32       `json:"page_offset"`
	PageLimit  int32       `json:"page_limit"`
}

type ListFilesAdminRow struct {
	ID              pgtype.UUID        `json:"id"`
	TenantID        pgtype.UUID        `json:"tenant_id"`
	Filename        string             `json:"filename"`
	Purpose         string             `json:"purpose"`
	ContentType     string             `json:"content_type"`
	Bytes           int64              `json:"bytes"`
	StorageBackend  string             `json:"storage_backend"`
	StorageKey      string             `json:"storage_key"`
	Checksum        pgtype.Text        `json:"checksum"`
	Encrypted       bool               `json:"encrypted"`
	Metadata        []byte             `json:"metadata"`
	ExpiresAt       pgtype.Timestamptz `json:"expires_at"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	DeletedAt       pgtype.Timestamptz `json:"deleted_at"`
	Status          string             `json:"status"`
	StatusDetails   pgtype.Text        `json:"status_details"`
	StatusUpdatedAt pgtype.Timestamptz `json:"status_updated_at"`
	TenantName      string             `json:"tenant_name"`
	TotalCount      int64              `json:"total_count"`
}

func (q *Queries) ListFilesAdmin(ctx context.Context, arg ListFilesAdminParams) ([]ListFilesAdminRow, error) {
	rows, err := q.db.Query(ctx, listFilesAdmin,
		arg.TenantID,
		arg.Purpose,
		arg.Search,
		arg.State,
		arg.PageOffset,
		arg.PageLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListFilesAdminRow{}
	for rows.Next() {
		var i ListFilesAdminRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Filename,
			&i.Purpose,
			&i.ContentType,
			&i.Bytes,
			&i.StorageBackend,
			&i.StorageKey,
			&i.Checksum,
			&i.Encrypted,
			&i.Metadata,
			&i.ExpiresAt,
			&i.CreatedAt,
			&i.DeletedAt,
			&i.Status,
			&i.StatusDetails,
			&i.StatusUpdatedAt,
			&i.TenantName,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
