// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: guardrails.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const deleteAPIKeyGuardrailPolicy = `-- name: DeleteAPIKeyGuardrailPolicy :exec
DELETE FROM guardrail_policies
WHERE api_key_id = $1
`

func (q *Queries) DeleteAPIKeyGuardrailPolicy(ctx context.Context, apiKeyID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteAPIKeyGuardrailPolicy, apiKeyID)
	return err
}

const deleteTenantGuardrailPolicy = `-- name: DeleteTenantGuardrailPolicy :exec
DELETE FROM guardrail_policies
WHERE tenant_id = $1
`

func (q *Queries) DeleteTenantGuardrailPolicy(ctx context.Context, tenantID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteTenantGuardrailPolicy, tenantID)
	return err
}

const getAPIKeyGuardrailPolicy = `-- name: GetAPIKeyGuardrailPolicy :one
SELECT id, tenant_id, api_key_id, config_json, created_at, updated_at
FROM guardrail_policies
WHERE api_key_id = $1
`

func (q *Queries) GetAPIKeyGuardrailPolicy(ctx context.Context, apiKeyID pgtype.UUID) (GuardrailPolicy, error) {
	row := q.db.QueryRow(ctx, getAPIKeyGuardrailPolicy, apiKeyID)
	var i GuardrailPolicy
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.ApiKeyID,
		&i.ConfigJson,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTenantGuardrailPolicy = `-- name: GetTenantGuardrailPolicy :one
SELECT id, tenant_id, api_key_id, config_json, created_at, updated_at
FROM guardrail_policies
WHERE tenant_id = $1
`

func (q *Queries) GetTenantGuardrailPolicy(ctx context.Context, tenantID pgtype.UUID) (GuardrailPolicy, error) {
	row := q.db.QueryRow(ctx, getTenantGuardrailPolicy, tenantID)
	var i GuardrailPolicy
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.ApiKeyID,
		&i.ConfigJson,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const insertGuardrailEvent = `-- name: InsertGuardrailEvent :one
INSERT INTO guardrail_events (
    tenant_id,
    api_key_id,
    model_alias,
    action,
    category,
    details
)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, tenant_id, api_key_id, model_alias, action, category, details, created_at
`

type InsertGuardrailEventParams struct {
	TenantID   pgtype.UUID `json:"tenant_id"`
	ApiKeyID   pgtype.UUID `json:"api_key_id"`
	ModelAlias pgtype.Text `json:"model_alias"`
	Action     string      `json:"action"`
	Category   pgtype.Text `json:"category"`
	Details    []byte      `json:"details"`
}

func (q *Queries) InsertGuardrailEvent(ctx context.Context, arg InsertGuardrailEventParams) (GuardrailEvent, error) {
	row := q.db.QueryRow(ctx, insertGuardrailEvent,
		arg.TenantID,
		arg.ApiKeyID,
		arg.ModelAlias,
		arg.Action,
		arg.Category,
		arg.Details,
	)
	var i GuardrailEvent
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.ApiKeyID,
		&i.ModelAlias,
		&i.Action,
		&i.Category,
		&i.Details,
		&i.CreatedAt,
	)
	return i, err
}

const listGuardrailEvents = `-- name: ListGuardrailEvents :many
SELECT
    ge.id, ge.tenant_id, ge.api_key_id, ge.model_alias, ge.action, ge.category, ge.details, ge.created_at,
    t.name AS tenant_name,
    k.name AS api_key_name,
    COUNT(*) OVER() AS total_rows
FROM guardrail_events ge
LEFT JOIN tenants t ON ge.tenant_id = t.id
LEFT JOIN api_keys k ON ge.api_key_id = k.id
WHERE ($1::uuid IS NULL OR ge.tenant_id = $1)
  AND ($2::uuid IS NULL OR ge.api_key_id = $2)
  AND (($3)::text IS NULL OR ge.action = $3)
  AND (($4)::text IS NULL OR ge.details->>'stage' = $4)
  AND (($5)::text IS NULL OR ge.category = $5)
  AND (($6)::timestamptz IS NULL OR ge.created_at >= $6)
  AND (($7)::timestamptz IS NULL OR ge.created_at <= $7)
ORDER BY ge.created_at DESC
LIMIT $8 OFFSET $9
`

type ListGuardrailEventsParams struct {
	Column1 pgtype.UUID        `json:"column_1"`
	Column2 pgtype.UUID        `json:"column_2"`
	Column3 string             `json:"column_3"`
	Column4 string             `json:"column_4"`
	Column5 string             `json:"column_5"`
	Column6 pgtype.Timestamptz `json:"column_6"`
	Column7 pgtype.Timestamptz `json:"column_7"`
	Limit   int32              `json:"limit"`
	Offset  int32              `json:"offset"`
}

type ListGuardrailEventsRow struct {
	ID         pgtype.UUID        `json:"id"`
	TenantID   pgtype.UUID        `json:"tenant_id"`
	ApiKeyID   pgtype.UUID        `json:"api_key_id"`
	ModelAlias pgtype.Text        `json:"model_alias"`
	Action     string             `json:"action"`
	Category   pgtype.Text        `json:"category"`
	Details    []byte             `json:"details"`
	CreatedAt  pgtype.Timestamptz `json:"created_at"`
	TenantName pgtype.Text        `json:"tenant_name"`
	ApiKeyName pgtype.Text        `json:"api_key_name"`
	TotalRows  int64              `json:"total_rows"`
}

func (q *Queries) ListGuardrailEvents(ctx context.Context, arg ListGuardrailEventsParams) ([]ListGuardrailEventsRow, error) {
	rows, err := q.db.Query(ctx, listGuardrailEvents,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Column6,
		arg.Column7,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListGuardrailEventsRow{}
	for rows.Next() {
		var i ListGuardrailEventsRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.ApiKeyID,
			&i.ModelAlias,
			&i.Action,
			&i.Category,
			&i.Details,
			&i.CreatedAt,
			&i.TenantName,
			&i.ApiKeyName,
			&i.TotalRows,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertAPIKeyGuardrailPolicy = `-- name: UpsertAPIKeyGuardrailPolicy :one
INSERT INTO guardrail_policies (api_key_id, config_json)
VALUES ($1, $2)
ON CONFLICT (api_key_id)
DO UPDATE SET config_json = EXCLUDED.config_json, updated_at = NOW()
RETURNING id, tenant_id, api_key_id, config_json, created_at, updated_at
`

type UpsertAPIKeyGuardrailPolicyParams struct {
	ApiKeyID   pgtype.UUID `json:"api_key_id"`
	ConfigJson []byte      `json:"config_json"`
}

func (q *Queries) UpsertAPIKeyGuardrailPolicy(ctx context.Context, arg UpsertAPIKeyGuardrailPolicyParams) (GuardrailPolicy, error) {
	row := q.db.QueryRow(ctx, upsertAPIKeyGuardrailPolicy, arg.ApiKeyID, arg.ConfigJson)
	var i GuardrailPolicy
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.ApiKeyID,
		&i.ConfigJson,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertTenantGuardrailPolicy = `-- name: UpsertTenantGuardrailPolicy :one
INSERT INTO guardrail_policies (tenant_id, config_json)
VALUES ($1, $2)
ON CONFLICT (tenant_id)
DO UPDATE SET config_json = EXCLUDED.config_json, updated_at = NOW()
RETURNING id, tenant_id, api_key_id, config_json, created_at, updated_at
`

type UpsertTenantGuardrailPolicyParams struct {
	TenantID   pgtype.UUID `json:"tenant_id"`
	ConfigJson []byte      `json:"config_json"`
}

func (q *Queries) UpsertTenantGuardrailPolicy(ctx context.Context, arg UpsertTenantGuardrailPolicyParams) (GuardrailPolicy, error) {
	row := q.db.QueryRow(ctx, upsertTenantGuardrailPolicy, arg.TenantID, arg.ConfigJson)
	var i GuardrailPolicy
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.ApiKeyID,
		&i.ConfigJson,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
