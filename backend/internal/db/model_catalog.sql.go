// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: model_catalog.sql

package db

import (
	"context"

	decimal "github.com/shopspring/decimal"
)

const deleteModelCatalogEntry = `-- name: DeleteModelCatalogEntry :exec
DELETE FROM model_catalog
WHERE alias = $1
`

func (q *Queries) DeleteModelCatalogEntry(ctx context.Context, alias string) error {
	_, err := q.db.Exec(ctx, deleteModelCatalogEntry, alias)
	return err
}

const getModelByAlias = `-- name: GetModelByAlias :one
SELECT alias, provider, provider_model, model_type, context_window, max_output_tokens, modalities_json, supports_tools, price_input, price_output, currency, enabled, provider_config_json, updated_at, deployment, endpoint, api_key, api_version, region, metadata_json, weight
FROM model_catalog
WHERE alias = $1
`

func (q *Queries) GetModelByAlias(ctx context.Context, alias string) (ModelCatalog, error) {
	row := q.db.QueryRow(ctx, getModelByAlias, alias)
	var i ModelCatalog
	err := row.Scan(
		&i.Alias,
		&i.Provider,
		&i.ProviderModel,
		&i.ModelType,
		&i.ContextWindow,
		&i.MaxOutputTokens,
		&i.ModalitiesJson,
		&i.SupportsTools,
		&i.PriceInput,
		&i.PriceOutput,
		&i.Currency,
		&i.Enabled,
		&i.ProviderConfigJson,
		&i.UpdatedAt,
		&i.Deployment,
		&i.Endpoint,
		&i.ApiKey,
		&i.ApiVersion,
		&i.Region,
		&i.MetadataJson,
		&i.Weight,
	)
	return i, err
}

const listEnabledModels = `-- name: ListEnabledModels :many
SELECT alias, provider, provider_model, model_type, context_window, max_output_tokens, modalities_json, supports_tools, price_input, price_output, currency, enabled, provider_config_json, updated_at, deployment, endpoint, api_key, api_version, region, metadata_json, weight
FROM model_catalog
WHERE enabled = true
ORDER BY alias
`

func (q *Queries) ListEnabledModels(ctx context.Context) ([]ModelCatalog, error) {
	rows, err := q.db.Query(ctx, listEnabledModels)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ModelCatalog{}
	for rows.Next() {
		var i ModelCatalog
		if err := rows.Scan(
			&i.Alias,
			&i.Provider,
			&i.ProviderModel,
			&i.ModelType,
			&i.ContextWindow,
			&i.MaxOutputTokens,
			&i.ModalitiesJson,
			&i.SupportsTools,
			&i.PriceInput,
			&i.PriceOutput,
			&i.Currency,
			&i.Enabled,
			&i.ProviderConfigJson,
			&i.UpdatedAt,
			&i.Deployment,
			&i.Endpoint,
			&i.ApiKey,
			&i.ApiVersion,
			&i.Region,
			&i.MetadataJson,
			&i.Weight,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listModelCatalog = `-- name: ListModelCatalog :many
SELECT alias, provider, provider_model, model_type, context_window, max_output_tokens, modalities_json, supports_tools, price_input, price_output, currency, enabled, provider_config_json, updated_at, deployment, endpoint, api_key, api_version, region, metadata_json, weight
FROM model_catalog
ORDER BY alias
`

func (q *Queries) ListModelCatalog(ctx context.Context) ([]ModelCatalog, error) {
	rows, err := q.db.Query(ctx, listModelCatalog)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ModelCatalog{}
	for rows.Next() {
		var i ModelCatalog
		if err := rows.Scan(
			&i.Alias,
			&i.Provider,
			&i.ProviderModel,
			&i.ModelType,
			&i.ContextWindow,
			&i.MaxOutputTokens,
			&i.ModalitiesJson,
			&i.SupportsTools,
			&i.PriceInput,
			&i.PriceOutput,
			&i.Currency,
			&i.Enabled,
			&i.ProviderConfigJson,
			&i.UpdatedAt,
			&i.Deployment,
			&i.Endpoint,
			&i.ApiKey,
			&i.ApiVersion,
			&i.Region,
			&i.MetadataJson,
			&i.Weight,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listModelCatalogByAliases = `-- name: ListModelCatalogByAliases :many
SELECT alias, provider, provider_model, model_type, context_window, max_output_tokens, modalities_json, supports_tools, price_input, price_output, currency, enabled, provider_config_json, updated_at, deployment, endpoint, api_key, api_version, region, metadata_json, weight
FROM model_catalog
WHERE alias = ANY($1::text[])
`

func (q *Queries) ListModelCatalogByAliases(ctx context.Context, dollar_1 []string) ([]ModelCatalog, error) {
	rows, err := q.db.Query(ctx, listModelCatalogByAliases, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ModelCatalog{}
	for rows.Next() {
		var i ModelCatalog
		if err := rows.Scan(
			&i.Alias,
			&i.Provider,
			&i.ProviderModel,
			&i.ModelType,
			&i.ContextWindow,
			&i.MaxOutputTokens,
			&i.ModalitiesJson,
			&i.SupportsTools,
			&i.PriceInput,
			&i.PriceOutput,
			&i.Currency,
			&i.Enabled,
			&i.ProviderConfigJson,
			&i.UpdatedAt,
			&i.Deployment,
			&i.Endpoint,
			&i.ApiKey,
			&i.ApiVersion,
			&i.Region,
			&i.MetadataJson,
			&i.Weight,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertModelCatalogEntry = `-- name: UpsertModelCatalogEntry :one
INSERT INTO model_catalog (
    alias,
    provider,
    provider_model,
    model_type,
    context_window,
    max_output_tokens,
    modalities_json,
    supports_tools,
    price_input,
    price_output,
    currency,
    enabled,
    deployment,
    endpoint,
    api_key,
    api_version,
    region,
    metadata_json,
    weight,
    provider_config_json
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20)
ON CONFLICT (alias)
DO UPDATE SET
    provider = EXCLUDED.provider,
    provider_model = EXCLUDED.provider_model,
    model_type = EXCLUDED.model_type,
    context_window = EXCLUDED.context_window,
    max_output_tokens = EXCLUDED.max_output_tokens,
    modalities_json = EXCLUDED.modalities_json,
    supports_tools = EXCLUDED.supports_tools,
    price_input = EXCLUDED.price_input,
    price_output = EXCLUDED.price_output,
    currency = EXCLUDED.currency,
    enabled = EXCLUDED.enabled,
    deployment = EXCLUDED.deployment,
    endpoint = EXCLUDED.endpoint,
    api_key = EXCLUDED.api_key,
    api_version = EXCLUDED.api_version,
    region = EXCLUDED.region,
    metadata_json = EXCLUDED.metadata_json,
    weight = EXCLUDED.weight,
    provider_config_json = EXCLUDED.provider_config_json,
    updated_at = NOW()
RETURNING alias, provider, provider_model, model_type, context_window, max_output_tokens, modalities_json, supports_tools, price_input, price_output, currency, enabled, provider_config_json, updated_at, deployment, endpoint, api_key, api_version, region, metadata_json, weight
`

type UpsertModelCatalogEntryParams struct {
	Alias              string          `json:"alias"`
	Provider           string          `json:"provider"`
	ProviderModel      string          `json:"provider_model"`
	ModelType          string          `json:"model_type"`
	ContextWindow      int32           `json:"context_window"`
	MaxOutputTokens    int32           `json:"max_output_tokens"`
	ModalitiesJson     []byte          `json:"modalities_json"`
	SupportsTools      bool            `json:"supports_tools"`
	PriceInput         decimal.Decimal `json:"price_input"`
	PriceOutput        decimal.Decimal `json:"price_output"`
	Currency           string          `json:"currency"`
	Enabled            bool            `json:"enabled"`
	Deployment         string          `json:"deployment"`
	Endpoint           string          `json:"endpoint"`
	ApiKey             string          `json:"api_key"`
	ApiVersion         string          `json:"api_version"`
	Region             string          `json:"region"`
	MetadataJson       []byte          `json:"metadata_json"`
	Weight             int32           `json:"weight"`
	ProviderConfigJson []byte          `json:"provider_config_json"`
}

func (q *Queries) UpsertModelCatalogEntry(ctx context.Context, arg UpsertModelCatalogEntryParams) (ModelCatalog, error) {
	row := q.db.QueryRow(ctx, upsertModelCatalogEntry,
		arg.Alias,
		arg.Provider,
		arg.ProviderModel,
		arg.ModelType,
		arg.ContextWindow,
		arg.MaxOutputTokens,
		arg.ModalitiesJson,
		arg.SupportsTools,
		arg.PriceInput,
		arg.PriceOutput,
		arg.Currency,
		arg.Enabled,
		arg.Deployment,
		arg.Endpoint,
		arg.ApiKey,
		arg.ApiVersion,
		arg.Region,
		arg.MetadataJson,
		arg.Weight,
		arg.ProviderConfigJson,
	)
	var i ModelCatalog
	err := row.Scan(
		&i.Alias,
		&i.Provider,
		&i.ProviderModel,
		&i.ModelType,
		&i.ContextWindow,
		&i.MaxOutputTokens,
		&i.ModalitiesJson,
		&i.SupportsTools,
		&i.PriceInput,
		&i.PriceOutput,
		&i.Currency,
		&i.Enabled,
		&i.ProviderConfigJson,
		&i.UpdatedAt,
		&i.Deployment,
		&i.Endpoint,
		&i.ApiKey,
		&i.ApiVersion,
		&i.Region,
		&i.MetadataJson,
		&i.Weight,
	)
	return i, err
}
