// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: requests.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const aggregateLatencyByModel = `-- name: AggregateLatencyByModel :many
SELECT
    model_alias,
    COALESCE(AVG(latency_ms), 0)::double precision AS avg_latency_ms,
    COALESCE(PERCENTILE_CONT(0.95) WITHIN GROUP (ORDER BY latency_ms), 0)::double precision AS p95_latency_ms,
    COUNT(*)::bigint AS sample_count
FROM requests
WHERE ts >= $1
  AND ts < $2
GROUP BY model_alias
`

type AggregateLatencyByModelParams struct {
	Ts   pgtype.Timestamptz `json:"ts"`
	Ts_2 pgtype.Timestamptz `json:"ts_2"`
}

type AggregateLatencyByModelRow struct {
	ModelAlias   string  `json:"model_alias"`
	AvgLatencyMs float64 `json:"avg_latency_ms"`
	P95LatencyMs float64 `json:"p95_latency_ms"`
	SampleCount  int64   `json:"sample_count"`
}

func (q *Queries) AggregateLatencyByModel(ctx context.Context, arg AggregateLatencyByModelParams) ([]AggregateLatencyByModelRow, error) {
	rows, err := q.db.Query(ctx, aggregateLatencyByModel, arg.Ts, arg.Ts_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AggregateLatencyByModelRow{}
	for rows.Next() {
		var i AggregateLatencyByModelRow
		if err := rows.Scan(
			&i.ModelAlias,
			&i.AvgLatencyMs,
			&i.P95LatencyMs,
			&i.SampleCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const aggregateRequestMetricsByModel = `-- name: AggregateRequestMetricsByModel :many
SELECT
    model_alias,
    COALESCE(SUM(input_tokens + output_tokens), 0)::bigint AS tokens,
    COUNT(*)::bigint AS requests
FROM requests
WHERE ts >= $1
  AND ts < $2
GROUP BY model_alias
`

type AggregateRequestMetricsByModelParams struct {
	Ts   pgtype.Timestamptz `json:"ts"`
	Ts_2 pgtype.Timestamptz `json:"ts_2"`
}

type AggregateRequestMetricsByModelRow struct {
	ModelAlias string `json:"model_alias"`
	Tokens     int64  `json:"tokens"`
	Requests   int64  `json:"requests"`
}

func (q *Queries) AggregateRequestMetricsByModel(ctx context.Context, arg AggregateRequestMetricsByModelParams) ([]AggregateRequestMetricsByModelRow, error) {
	rows, err := q.db.Query(ctx, aggregateRequestMetricsByModel, arg.Ts, arg.Ts_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AggregateRequestMetricsByModelRow{}
	for rows.Next() {
		var i AggregateRequestMetricsByModelRow
		if err := rows.Scan(&i.ModelAlias, &i.Tokens, &i.Requests); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRequestByIdempotencyKey = `-- name: GetRequestByIdempotencyKey :one
SELECT id, tenant_id, api_key_id, ts, model_alias, provider, latency_ms, status, error_code, input_tokens, output_tokens, cost_cents, cost_usd_micros, idempotency_key, trace_id
FROM requests
WHERE tenant_id = $1 AND idempotency_key = $2
`

type GetRequestByIdempotencyKeyParams struct {
	TenantID       pgtype.UUID `json:"tenant_id"`
	IdempotencyKey pgtype.Text `json:"idempotency_key"`
}

func (q *Queries) GetRequestByIdempotencyKey(ctx context.Context, arg GetRequestByIdempotencyKeyParams) (Request, error) {
	row := q.db.QueryRow(ctx, getRequestByIdempotencyKey, arg.TenantID, arg.IdempotencyKey)
	var i Request
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.ApiKeyID,
		&i.Ts,
		&i.ModelAlias,
		&i.Provider,
		&i.LatencyMs,
		&i.Status,
		&i.ErrorCode,
		&i.InputTokens,
		&i.OutputTokens,
		&i.CostCents,
		&i.CostUsdMicros,
		&i.IdempotencyKey,
		&i.TraceID,
	)
	return i, err
}

const insertRequestRecord = `-- name: InsertRequestRecord :one
INSERT INTO requests (
    tenant_id,
    api_key_id,
    ts,
    model_alias,
    provider,
    latency_ms,
    status,
    error_code,
    input_tokens,
    output_tokens,
    cost_cents,
    cost_usd_micros,
    idempotency_key,
    trace_id
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14)
RETURNING id, tenant_id, api_key_id, ts, model_alias, provider, latency_ms, status, error_code, input_tokens, output_tokens, cost_cents, cost_usd_micros, idempotency_key, trace_id
`

type InsertRequestRecordParams struct {
	TenantID       pgtype.UUID        `json:"tenant_id"`
	ApiKeyID       pgtype.UUID        `json:"api_key_id"`
	Ts             pgtype.Timestamptz `json:"ts"`
	ModelAlias     string             `json:"model_alias"`
	Provider       string             `json:"provider"`
	LatencyMs      int32              `json:"latency_ms"`
	Status         int32              `json:"status"`
	ErrorCode      pgtype.Text        `json:"error_code"`
	InputTokens    int64              `json:"input_tokens"`
	OutputTokens   int64              `json:"output_tokens"`
	CostCents      int64              `json:"cost_cents"`
	CostUsdMicros  int64              `json:"cost_usd_micros"`
	IdempotencyKey pgtype.Text        `json:"idempotency_key"`
	TraceID        pgtype.Text        `json:"trace_id"`
}

func (q *Queries) InsertRequestRecord(ctx context.Context, arg InsertRequestRecordParams) (Request, error) {
	row := q.db.QueryRow(ctx, insertRequestRecord,
		arg.TenantID,
		arg.ApiKeyID,
		arg.Ts,
		arg.ModelAlias,
		arg.Provider,
		arg.LatencyMs,
		arg.Status,
		arg.ErrorCode,
		arg.InputTokens,
		arg.OutputTokens,
		arg.CostCents,
		arg.CostUsdMicros,
		arg.IdempotencyKey,
		arg.TraceID,
	)
	var i Request
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.ApiKeyID,
		&i.Ts,
		&i.ModelAlias,
		&i.Provider,
		&i.LatencyMs,
		&i.Status,
		&i.ErrorCode,
		&i.InputTokens,
		&i.OutputTokens,
		&i.CostCents,
		&i.CostUsdMicros,
		&i.IdempotencyKey,
		&i.TraceID,
	)
	return i, err
}

const listRecentRequestsByAPIKeys = `-- name: ListRecentRequestsByAPIKeys :many
SELECT id, tenant_id, api_key_id, ts, model_alias, provider, latency_ms, status, error_code, input_tokens, output_tokens, cost_cents, cost_usd_micros, idempotency_key, trace_id
FROM requests
WHERE api_key_id = ANY($1::uuid[])
ORDER BY ts DESC
LIMIT $2
`

type ListRecentRequestsByAPIKeysParams struct {
	Column1 []pgtype.UUID `json:"column_1"`
	Limit   int32         `json:"limit"`
}

func (q *Queries) ListRecentRequestsByAPIKeys(ctx context.Context, arg ListRecentRequestsByAPIKeysParams) ([]Request, error) {
	rows, err := q.db.Query(ctx, listRecentRequestsByAPIKeys, arg.Column1, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Request{}
	for rows.Next() {
		var i Request
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.ApiKeyID,
			&i.Ts,
			&i.ModelAlias,
			&i.Provider,
			&i.LatencyMs,
			&i.Status,
			&i.ErrorCode,
			&i.InputTokens,
			&i.OutputTokens,
			&i.CostCents,
			&i.CostUsdMicros,
			&i.IdempotencyKey,
			&i.TraceID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRequests = `-- name: ListRequests :many
SELECT id, tenant_id, api_key_id, ts, model_alias, provider, latency_ms, status, error_code, input_tokens, output_tokens, cost_cents, cost_usd_micros, idempotency_key, trace_id
FROM requests
WHERE tenant_id = $1
  AND ts >= $2
  AND ts < $3
ORDER BY ts DESC
LIMIT $4 OFFSET $5
`

type ListRequestsParams struct {
	TenantID pgtype.UUID        `json:"tenant_id"`
	Ts       pgtype.Timestamptz `json:"ts"`
	Ts_2     pgtype.Timestamptz `json:"ts_2"`
	Limit    int32              `json:"limit"`
	Offset   int32              `json:"offset"`
}

func (q *Queries) ListRequests(ctx context.Context, arg ListRequestsParams) ([]Request, error) {
	rows, err := q.db.Query(ctx, listRequests,
		arg.TenantID,
		arg.Ts,
		arg.Ts_2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Request{}
	for rows.Next() {
		var i Request
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.ApiKeyID,
			&i.Ts,
			&i.ModelAlias,
			&i.Provider,
			&i.LatencyMs,
			&i.Status,
			&i.ErrorCode,
			&i.InputTokens,
			&i.OutputTokens,
			&i.CostCents,
			&i.CostUsdMicros,
			&i.IdempotencyKey,
			&i.TraceID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
