// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: routes.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const deleteRoute = `-- name: DeleteRoute :exec
DELETE FROM routes
WHERE id = $1
`

func (q *Queries) DeleteRoute(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteRoute, id)
	return err
}

const listRoutesByAlias = `-- name: ListRoutesByAlias :many
SELECT id, tenant_id, alias, provider, provider_model, weight, params_json, region, sticky_key, enabled, created_at, updated_at
FROM routes
WHERE tenant_id = $1 AND alias = $2 AND enabled = true
ORDER BY weight DESC, created_at DESC
`

type ListRoutesByAliasParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Alias    string      `json:"alias"`
}

func (q *Queries) ListRoutesByAlias(ctx context.Context, arg ListRoutesByAliasParams) ([]Route, error) {
	rows, err := q.db.Query(ctx, listRoutesByAlias, arg.TenantID, arg.Alias)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Route{}
	for rows.Next() {
		var i Route
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Alias,
			&i.Provider,
			&i.ProviderModel,
			&i.Weight,
			&i.ParamsJson,
			&i.Region,
			&i.StickyKey,
			&i.Enabled,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRoutesByTenant = `-- name: ListRoutesByTenant :many
SELECT id, tenant_id, alias, provider, provider_model, weight, params_json, region, sticky_key, enabled, created_at, updated_at
FROM routes
WHERE tenant_id = $1
ORDER BY alias, created_at DESC
`

func (q *Queries) ListRoutesByTenant(ctx context.Context, tenantID pgtype.UUID) ([]Route, error) {
	rows, err := q.db.Query(ctx, listRoutesByTenant, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Route{}
	for rows.Next() {
		var i Route
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Alias,
			&i.Provider,
			&i.ProviderModel,
			&i.Weight,
			&i.ParamsJson,
			&i.Region,
			&i.StickyKey,
			&i.Enabled,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertRoute = `-- name: UpsertRoute :one
INSERT INTO routes (
    tenant_id,
    alias,
    provider,
    provider_model,
    weight,
    params_json,
    region,
    sticky_key,
    enabled
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
ON CONFLICT (tenant_id, alias, provider, provider_model)
DO UPDATE SET
    weight = EXCLUDED.weight,
    params_json = EXCLUDED.params_json,
    region = EXCLUDED.region,
    sticky_key = EXCLUDED.sticky_key,
    enabled = EXCLUDED.enabled,
    updated_at = NOW()
RETURNING id, tenant_id, alias, provider, provider_model, weight, params_json, region, sticky_key, enabled, created_at, updated_at
`

type UpsertRouteParams struct {
	TenantID      pgtype.UUID `json:"tenant_id"`
	Alias         string      `json:"alias"`
	Provider      string      `json:"provider"`
	ProviderModel string      `json:"provider_model"`
	Weight        int32       `json:"weight"`
	ParamsJson    []byte      `json:"params_json"`
	Region        pgtype.Text `json:"region"`
	StickyKey     pgtype.Text `json:"sticky_key"`
	Enabled       bool        `json:"enabled"`
}

func (q *Queries) UpsertRoute(ctx context.Context, arg UpsertRouteParams) (Route, error) {
	row := q.db.QueryRow(ctx, upsertRoute,
		arg.TenantID,
		arg.Alias,
		arg.Provider,
		arg.ProviderModel,
		arg.Weight,
		arg.ParamsJson,
		arg.Region,
		arg.StickyKey,
		arg.Enabled,
	)
	var i Route
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Alias,
		&i.Provider,
		&i.ProviderModel,
		&i.Weight,
		&i.ParamsJson,
		&i.Region,
		&i.StickyKey,
		&i.Enabled,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
