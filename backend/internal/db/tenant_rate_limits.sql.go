// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: tenant_rate_limits.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const deleteTenantRateLimit = `-- name: DeleteTenantRateLimit :exec
DELETE FROM tenant_rate_limits
WHERE tenant_id = $1
`

func (q *Queries) DeleteTenantRateLimit(ctx context.Context, tenantID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteTenantRateLimit, tenantID)
	return err
}

const getTenantRateLimit = `-- name: GetTenantRateLimit :one
SELECT tenant_id, requests_per_minute, tokens_per_minute, parallel_requests, created_at, updated_at
FROM tenant_rate_limits
WHERE tenant_id = $1
`

func (q *Queries) GetTenantRateLimit(ctx context.Context, tenantID pgtype.UUID) (TenantRateLimit, error) {
	row := q.db.QueryRow(ctx, getTenantRateLimit, tenantID)
	var i TenantRateLimit
	err := row.Scan(
		&i.TenantID,
		&i.RequestsPerMinute,
		&i.TokensPerMinute,
		&i.ParallelRequests,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listTenantRateLimits = `-- name: ListTenantRateLimits :many
SELECT tenant_id, requests_per_minute, tokens_per_minute, parallel_requests, created_at, updated_at
FROM tenant_rate_limits
`

func (q *Queries) ListTenantRateLimits(ctx context.Context) ([]TenantRateLimit, error) {
	rows, err := q.db.Query(ctx, listTenantRateLimits)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TenantRateLimit{}
	for rows.Next() {
		var i TenantRateLimit
		if err := rows.Scan(
			&i.TenantID,
			&i.RequestsPerMinute,
			&i.TokensPerMinute,
			&i.ParallelRequests,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertTenantRateLimit = `-- name: UpsertTenantRateLimit :one
INSERT INTO tenant_rate_limits (
    tenant_id,
    requests_per_minute,
    tokens_per_minute,
    parallel_requests
) VALUES ($1, $2, $3, $4)
ON CONFLICT (tenant_id) DO UPDATE
SET requests_per_minute = EXCLUDED.requests_per_minute,
    tokens_per_minute = EXCLUDED.tokens_per_minute,
    parallel_requests = EXCLUDED.parallel_requests,
    updated_at = NOW()
RETURNING tenant_id, requests_per_minute, tokens_per_minute, parallel_requests, created_at, updated_at
`

type UpsertTenantRateLimitParams struct {
	TenantID          pgtype.UUID `json:"tenant_id"`
	RequestsPerMinute int32       `json:"requests_per_minute"`
	TokensPerMinute   int32       `json:"tokens_per_minute"`
	ParallelRequests  int32       `json:"parallel_requests"`
}

func (q *Queries) UpsertTenantRateLimit(ctx context.Context, arg UpsertTenantRateLimitParams) (TenantRateLimit, error) {
	row := q.db.QueryRow(ctx, upsertTenantRateLimit,
		arg.TenantID,
		arg.RequestsPerMinute,
		arg.TokensPerMinute,
		arg.ParallelRequests,
	)
	var i TenantRateLimit
	err := row.Scan(
		&i.TenantID,
		&i.RequestsPerMinute,
		&i.TokensPerMinute,
		&i.ParallelRequests,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
