// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: tenants.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createTenant = `-- name: CreateTenant :one
INSERT INTO tenants (name, status, kind)
VALUES ($1, $2, $3)
RETURNING id, name, status, kind, created_at
`

type CreateTenantParams struct {
	Name   string       `json:"name"`
	Status TenantStatus `json:"status"`
	Kind   TenantKind   `json:"kind"`
}

func (q *Queries) CreateTenant(ctx context.Context, arg CreateTenantParams) (Tenant, error) {
	row := q.db.QueryRow(ctx, createTenant, arg.Name, arg.Status, arg.Kind)
	var i Tenant
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Status,
		&i.Kind,
		&i.CreatedAt,
	)
	return i, err
}

const getTenantByID = `-- name: GetTenantByID :one
SELECT id, name, status, kind, created_at
FROM tenants
WHERE id = $1
`

func (q *Queries) GetTenantByID(ctx context.Context, id pgtype.UUID) (Tenant, error) {
	row := q.db.QueryRow(ctx, getTenantByID, id)
	var i Tenant
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Status,
		&i.Kind,
		&i.CreatedAt,
	)
	return i, err
}

const getTenantByName = `-- name: GetTenantByName :one
SELECT id, name, status, kind, created_at
FROM tenants
WHERE name = $1
`

func (q *Queries) GetTenantByName(ctx context.Context, name string) (Tenant, error) {
	row := q.db.QueryRow(ctx, getTenantByName, name)
	var i Tenant
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Status,
		&i.Kind,
		&i.CreatedAt,
	)
	return i, err
}

const listPersonalTenantIDs = `-- name: ListPersonalTenantIDs :many
SELECT id
FROM tenants
WHERE kind = 'personal'
`

func (q *Queries) ListPersonalTenantIDs(ctx context.Context) ([]pgtype.UUID, error) {
	rows, err := q.db.Query(ctx, listPersonalTenantIDs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []pgtype.UUID{}
	for rows.Next() {
		var id pgtype.UUID
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPersonalTenants = `-- name: ListPersonalTenants :many
SELECT
    t.id,
    t.name,
    t.status,
    t.created_at,
    u.id AS user_id,
    u.email AS user_email,
    u.name AS user_name,
    u.created_at AS user_created_at,
    COALESCE(mc.membership_count, 0) AS membership_count
FROM tenants t
JOIN users u ON u.personal_tenant_id = t.id
LEFT JOIN (
    SELECT user_id, COUNT(DISTINCT tenant_id) AS membership_count
    FROM tenant_memberships
    GROUP BY user_id
) mc ON mc.user_id = u.id
WHERE t.kind = 'personal'
ORDER BY u.created_at DESC
LIMIT $1 OFFSET $2
`

type ListPersonalTenantsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListPersonalTenantsRow struct {
	ID              pgtype.UUID        `json:"id"`
	Name            string             `json:"name"`
	Status          TenantStatus       `json:"status"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	UserID          pgtype.UUID        `json:"user_id"`
	UserEmail       string             `json:"user_email"`
	UserName        string             `json:"user_name"`
	UserCreatedAt   pgtype.Timestamptz `json:"user_created_at"`
	MembershipCount int64              `json:"membership_count"`
}

func (q *Queries) ListPersonalTenants(ctx context.Context, arg ListPersonalTenantsParams) ([]ListPersonalTenantsRow, error) {
	rows, err := q.db.Query(ctx, listPersonalTenants, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListPersonalTenantsRow{}
	for rows.Next() {
		var i ListPersonalTenantsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Status,
			&i.CreatedAt,
			&i.UserID,
			&i.UserEmail,
			&i.UserName,
			&i.UserCreatedAt,
			&i.MembershipCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTenants = `-- name: ListTenants :many
SELECT id, name, status, kind, created_at
FROM tenants
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListTenantsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListTenants(ctx context.Context, arg ListTenantsParams) ([]Tenant, error) {
	rows, err := q.db.Query(ctx, listTenants, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Tenant{}
	for rows.Next() {
		var i Tenant
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Status,
			&i.Kind,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTenantsByIDs = `-- name: ListTenantsByIDs :many
SELECT id, name, status, kind
FROM tenants
WHERE id = ANY($1::uuid[])
`

type ListTenantsByIDsRow struct {
	ID     pgtype.UUID  `json:"id"`
	Name   string       `json:"name"`
	Status TenantStatus `json:"status"`
	Kind   TenantKind   `json:"kind"`
}

func (q *Queries) ListTenantsByIDs(ctx context.Context, dollar_1 []pgtype.UUID) ([]ListTenantsByIDsRow, error) {
	rows, err := q.db.Query(ctx, listTenantsByIDs, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListTenantsByIDsRow{}
	for rows.Next() {
		var i ListTenantsByIDsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Status,
			&i.Kind,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTenantName = `-- name: UpdateTenantName :one
UPDATE tenants
SET name = $2
WHERE id = $1
RETURNING id, name, status, kind, created_at
`

type UpdateTenantNameParams struct {
	ID   pgtype.UUID `json:"id"`
	Name string      `json:"name"`
}

func (q *Queries) UpdateTenantName(ctx context.Context, arg UpdateTenantNameParams) (Tenant, error) {
	row := q.db.QueryRow(ctx, updateTenantName, arg.ID, arg.Name)
	var i Tenant
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Status,
		&i.Kind,
		&i.CreatedAt,
	)
	return i, err
}

const updateTenantStatus = `-- name: UpdateTenantStatus :one
UPDATE tenants
SET status = $2
WHERE id = $1
RETURNING id, name, status, kind, created_at
`

type UpdateTenantStatusParams struct {
	ID     pgtype.UUID  `json:"id"`
	Status TenantStatus `json:"status"`
}

func (q *Queries) UpdateTenantStatus(ctx context.Context, arg UpdateTenantStatusParams) (Tenant, error) {
	row := q.db.QueryRow(ctx, updateTenantStatus, arg.ID, arg.Status)
	var i Tenant
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Status,
		&i.Kind,
		&i.CreatedAt,
	)
	return i, err
}
