// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: usage.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const aggregateAPIKeyUsageDaily = `-- name: AggregateAPIKeyUsageDaily :many
SELECT
    timezone($4::text, date_trunc('day', ts AT TIME ZONE $4::text))::timestamptz AS day,
    COALESCE(SUM(requests), 0)::bigint AS requests,
    COALESCE(SUM(input_tokens + output_tokens), 0)::bigint AS tokens,
    COALESCE(SUM(cost_cents), 0)::bigint AS cost_cents,
    COALESCE(SUM(cost_usd_micros), 0)::bigint AS cost_usd_micros
FROM usage_records
WHERE api_key_id = $1
  AND ts >= $2
  AND ts < $3
GROUP BY day
ORDER BY day
`

type AggregateAPIKeyUsageDailyParams struct {
	ApiKeyID pgtype.UUID        `json:"api_key_id"`
	Ts       pgtype.Timestamptz `json:"ts"`
	Ts_2     pgtype.Timestamptz `json:"ts_2"`
	Column4  string             `json:"column_4"`
}

type AggregateAPIKeyUsageDailyRow struct {
	Day           pgtype.Timestamptz `json:"day"`
	Requests      int64              `json:"requests"`
	Tokens        int64              `json:"tokens"`
	CostCents     int64              `json:"cost_cents"`
	CostUsdMicros int64              `json:"cost_usd_micros"`
}

func (q *Queries) AggregateAPIKeyUsageDaily(ctx context.Context, arg AggregateAPIKeyUsageDailyParams) ([]AggregateAPIKeyUsageDailyRow, error) {
	rows, err := q.db.Query(ctx, aggregateAPIKeyUsageDaily,
		arg.ApiKeyID,
		arg.Ts,
		arg.Ts_2,
		arg.Column4,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AggregateAPIKeyUsageDailyRow{}
	for rows.Next() {
		var i AggregateAPIKeyUsageDailyRow
		if err := rows.Scan(
			&i.Day,
			&i.Requests,
			&i.Tokens,
			&i.CostCents,
			&i.CostUsdMicros,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const aggregateGuardrailByModel = `-- name: AggregateGuardrailByModel :many
SELECT
    model_alias,
    COUNT(*) FILTER (WHERE error_code = 'guardrail_blocked')::bigint AS guardrail_blocks
FROM requests
WHERE ts >= $1
  AND ts < $2
GROUP BY model_alias
`

type AggregateGuardrailByModelParams struct {
	Ts   pgtype.Timestamptz `json:"ts"`
	Ts_2 pgtype.Timestamptz `json:"ts_2"`
}

type AggregateGuardrailByModelRow struct {
	ModelAlias      string `json:"model_alias"`
	GuardrailBlocks int64  `json:"guardrail_blocks"`
}

func (q *Queries) AggregateGuardrailByModel(ctx context.Context, arg AggregateGuardrailByModelParams) ([]AggregateGuardrailByModelRow, error) {
	rows, err := q.db.Query(ctx, aggregateGuardrailByModel, arg.Ts, arg.Ts_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AggregateGuardrailByModelRow{}
	for rows.Next() {
		var i AggregateGuardrailByModelRow
		if err := rows.Scan(&i.ModelAlias, &i.GuardrailBlocks); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const aggregateGuardrailByTenant = `-- name: AggregateGuardrailByTenant :many
SELECT
    tenant_id,
    COUNT(*) FILTER (WHERE error_code = 'guardrail_blocked')::bigint AS guardrail_blocks
FROM requests
WHERE ts >= $1
  AND ts < $2
GROUP BY tenant_id
`

type AggregateGuardrailByTenantParams struct {
	Ts   pgtype.Timestamptz `json:"ts"`
	Ts_2 pgtype.Timestamptz `json:"ts_2"`
}

type AggregateGuardrailByTenantRow struct {
	TenantID        pgtype.UUID `json:"tenant_id"`
	GuardrailBlocks int64       `json:"guardrail_blocks"`
}

func (q *Queries) AggregateGuardrailByTenant(ctx context.Context, arg AggregateGuardrailByTenantParams) ([]AggregateGuardrailByTenantRow, error) {
	rows, err := q.db.Query(ctx, aggregateGuardrailByTenant, arg.Ts, arg.Ts_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AggregateGuardrailByTenantRow{}
	for rows.Next() {
		var i AggregateGuardrailByTenantRow
		if err := rows.Scan(&i.TenantID, &i.GuardrailBlocks); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const aggregateGuardrailByUser = `-- name: AggregateGuardrailByUser :many
SELECT
    k.owner_user_id AS user_id,
    COUNT(*) FILTER (WHERE r.error_code = 'guardrail_blocked')::bigint AS guardrail_blocks
FROM requests r
JOIN api_keys k ON r.api_key_id = k.id
WHERE r.ts >= $1
  AND r.ts < $2
GROUP BY k.owner_user_id
`

type AggregateGuardrailByUserParams struct {
	Ts   pgtype.Timestamptz `json:"ts"`
	Ts_2 pgtype.Timestamptz `json:"ts_2"`
}

type AggregateGuardrailByUserRow struct {
	UserID          pgtype.UUID `json:"user_id"`
	GuardrailBlocks int64       `json:"guardrail_blocks"`
}

func (q *Queries) AggregateGuardrailByUser(ctx context.Context, arg AggregateGuardrailByUserParams) ([]AggregateGuardrailByUserRow, error) {
	rows, err := q.db.Query(ctx, aggregateGuardrailByUser, arg.Ts, arg.Ts_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AggregateGuardrailByUserRow{}
	for rows.Next() {
		var i AggregateGuardrailByUserRow
		if err := rows.Scan(&i.UserID, &i.GuardrailBlocks); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const aggregateGuardrailDaily = `-- name: AggregateGuardrailDaily :many
SELECT
    timezone($4::text, date_trunc('day', ts AT TIME ZONE $4::text))::timestamptz AS day,
    COUNT(*) FILTER (WHERE error_code = 'guardrail_blocked')::bigint AS guardrail_blocks
FROM requests
WHERE ($1::uuid IS NULL OR tenant_id = $1)
  AND ts >= $2
  AND ts < $3
GROUP BY day
ORDER BY day
`

type AggregateGuardrailDailyParams struct {
	Column1 pgtype.UUID        `json:"column_1"`
	Ts      pgtype.Timestamptz `json:"ts"`
	Ts_2    pgtype.Timestamptz `json:"ts_2"`
	Column4 string             `json:"column_4"`
}

type AggregateGuardrailDailyRow struct {
	Day             pgtype.Timestamptz `json:"day"`
	GuardrailBlocks int64              `json:"guardrail_blocks"`
}

func (q *Queries) AggregateGuardrailDaily(ctx context.Context, arg AggregateGuardrailDailyParams) ([]AggregateGuardrailDailyRow, error) {
	rows, err := q.db.Query(ctx, aggregateGuardrailDaily,
		arg.Column1,
		arg.Ts,
		arg.Ts_2,
		arg.Column4,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AggregateGuardrailDailyRow{}
	for rows.Next() {
		var i AggregateGuardrailDailyRow
		if err := rows.Scan(&i.Day, &i.GuardrailBlocks); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const aggregateModelUsageDaily = `-- name: AggregateModelUsageDaily :many
SELECT
    timezone($4::text, date_trunc('day', ts AT TIME ZONE $4::text))::timestamptz AS day,
    COALESCE(SUM(requests), 0)::bigint AS requests,
    COALESCE(SUM(input_tokens + output_tokens), 0)::bigint AS tokens,
    COALESCE(SUM(cost_cents), 0)::bigint AS cost_cents,
    COALESCE(SUM(cost_usd_micros), 0)::bigint AS cost_usd_micros
FROM usage_records
WHERE model_alias = $1
  AND ts >= $2
  AND ts < $3
GROUP BY day
ORDER BY day
`

type AggregateModelUsageDailyParams struct {
	ModelAlias string             `json:"model_alias"`
	Ts         pgtype.Timestamptz `json:"ts"`
	Ts_2       pgtype.Timestamptz `json:"ts_2"`
	Column4    string             `json:"column_4"`
}

type AggregateModelUsageDailyRow struct {
	Day           pgtype.Timestamptz `json:"day"`
	Requests      int64              `json:"requests"`
	Tokens        int64              `json:"tokens"`
	CostCents     int64              `json:"cost_cents"`
	CostUsdMicros int64              `json:"cost_usd_micros"`
}

func (q *Queries) AggregateModelUsageDaily(ctx context.Context, arg AggregateModelUsageDailyParams) ([]AggregateModelUsageDailyRow, error) {
	rows, err := q.db.Query(ctx, aggregateModelUsageDaily,
		arg.ModelAlias,
		arg.Ts,
		arg.Ts_2,
		arg.Column4,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AggregateModelUsageDailyRow{}
	for rows.Next() {
		var i AggregateModelUsageDailyRow
		if err := rows.Scan(
			&i.Day,
			&i.Requests,
			&i.Tokens,
			&i.CostCents,
			&i.CostUsdMicros,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const aggregateModelUsageDailyByTenants = `-- name: AggregateModelUsageDailyByTenants :many
SELECT
    timezone($4::text, date_trunc('day', r.ts AT TIME ZONE $4::text))::timestamptz AS day,
    r.tenant_id,
    COALESCE(t.name, '') AS tenant_name,
    COALESCE(SUM(r.requests), 0)::bigint AS requests,
    COALESCE(SUM(r.input_tokens + r.output_tokens), 0)::bigint AS tokens,
    COALESCE(SUM(r.cost_cents), 0)::bigint AS cost_cents,
    COALESCE(SUM(r.cost_usd_micros), 0)::bigint AS cost_usd_micros
FROM usage_records r
LEFT JOIN tenants t ON t.id = r.tenant_id
WHERE r.model_alias = $1
  AND r.ts >= $2
  AND r.ts < $3
GROUP BY day, r.tenant_id, t.name
ORDER BY day, tenant_name
`

type AggregateModelUsageDailyByTenantsParams struct {
	ModelAlias string             `json:"model_alias"`
	Ts         pgtype.Timestamptz `json:"ts"`
	Ts_2       pgtype.Timestamptz `json:"ts_2"`
	Column4    string             `json:"column_4"`
}

type AggregateModelUsageDailyByTenantsRow struct {
	Day           pgtype.Timestamptz `json:"day"`
	TenantID      pgtype.UUID        `json:"tenant_id"`
	TenantName    string             `json:"tenant_name"`
	Requests      int64              `json:"requests"`
	Tokens        int64              `json:"tokens"`
	CostCents     int64              `json:"cost_cents"`
	CostUsdMicros int64              `json:"cost_usd_micros"`
}

func (q *Queries) AggregateModelUsageDailyByTenants(ctx context.Context, arg AggregateModelUsageDailyByTenantsParams) ([]AggregateModelUsageDailyByTenantsRow, error) {
	rows, err := q.db.Query(ctx, aggregateModelUsageDailyByTenants,
		arg.ModelAlias,
		arg.Ts,
		arg.Ts_2,
		arg.Column4,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AggregateModelUsageDailyByTenantsRow{}
	for rows.Next() {
		var i AggregateModelUsageDailyByTenantsRow
		if err := rows.Scan(
			&i.Day,
			&i.TenantID,
			&i.TenantName,
			&i.Requests,
			&i.Tokens,
			&i.CostCents,
			&i.CostUsdMicros,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const aggregateTenantUsageDaily = `-- name: AggregateTenantUsageDaily :many
SELECT
    timezone($4::text, date_trunc('day', ts AT TIME ZONE $4::text))::timestamptz AS day,
    COALESCE(SUM(requests), 0)::bigint AS requests,
    COALESCE(SUM(input_tokens + output_tokens), 0)::bigint AS tokens,
    COALESCE(SUM(cost_cents), 0)::bigint AS cost_cents,
    COALESCE(SUM(cost_usd_micros), 0)::bigint AS cost_usd_micros
FROM usage_records
WHERE tenant_id = $1
  AND ts >= $2
  AND ts < $3
GROUP BY day
ORDER BY day
`

type AggregateTenantUsageDailyParams struct {
	TenantID pgtype.UUID        `json:"tenant_id"`
	Ts       pgtype.Timestamptz `json:"ts"`
	Ts_2     pgtype.Timestamptz `json:"ts_2"`
	Column4  string             `json:"column_4"`
}

type AggregateTenantUsageDailyRow struct {
	Day           pgtype.Timestamptz `json:"day"`
	Requests      int64              `json:"requests"`
	Tokens        int64              `json:"tokens"`
	CostCents     int64              `json:"cost_cents"`
	CostUsdMicros int64              `json:"cost_usd_micros"`
}

func (q *Queries) AggregateTenantUsageDaily(ctx context.Context, arg AggregateTenantUsageDailyParams) ([]AggregateTenantUsageDailyRow, error) {
	rows, err := q.db.Query(ctx, aggregateTenantUsageDaily,
		arg.TenantID,
		arg.Ts,
		arg.Ts_2,
		arg.Column4,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AggregateTenantUsageDailyRow{}
	for rows.Next() {
		var i AggregateTenantUsageDailyRow
		if err := rows.Scan(
			&i.Day,
			&i.Requests,
			&i.Tokens,
			&i.CostCents,
			&i.CostUsdMicros,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const aggregateTenantUsageDailyByAPIKeys = `-- name: AggregateTenantUsageDailyByAPIKeys :many
SELECT
    timezone($4::text, date_trunc('day', r.ts AT TIME ZONE $4::text))::timestamptz AS day,
    r.api_key_id,
    COALESCE(k.name, '') AS api_key_name,
    COALESCE(k.prefix, '') AS api_key_prefix,
    COALESCE(SUM(r.requests), 0)::bigint AS requests,
    COALESCE(SUM(r.input_tokens + r.output_tokens), 0)::bigint AS tokens,
    COALESCE(SUM(r.cost_cents), 0)::bigint AS cost_cents,
    COALESCE(SUM(r.cost_usd_micros), 0)::bigint AS cost_usd_micros
FROM usage_records r
LEFT JOIN api_keys k ON k.id = r.api_key_id
WHERE r.tenant_id = $1
  AND r.ts >= $2
  AND r.ts < $3
GROUP BY day, r.api_key_id, k.name, k.prefix
ORDER BY day, api_key_name
`

type AggregateTenantUsageDailyByAPIKeysParams struct {
	TenantID pgtype.UUID        `json:"tenant_id"`
	Ts       pgtype.Timestamptz `json:"ts"`
	Ts_2     pgtype.Timestamptz `json:"ts_2"`
	Column4  string             `json:"column_4"`
}

type AggregateTenantUsageDailyByAPIKeysRow struct {
	Day           pgtype.Timestamptz `json:"day"`
	ApiKeyID      pgtype.UUID        `json:"api_key_id"`
	ApiKeyName    string             `json:"api_key_name"`
	ApiKeyPrefix  string             `json:"api_key_prefix"`
	Requests      int64              `json:"requests"`
	Tokens        int64              `json:"tokens"`
	CostCents     int64              `json:"cost_cents"`
	CostUsdMicros int64              `json:"cost_usd_micros"`
}

func (q *Queries) AggregateTenantUsageDailyByAPIKeys(ctx context.Context, arg AggregateTenantUsageDailyByAPIKeysParams) ([]AggregateTenantUsageDailyByAPIKeysRow, error) {
	rows, err := q.db.Query(ctx, aggregateTenantUsageDailyByAPIKeys,
		arg.TenantID,
		arg.Ts,
		arg.Ts_2,
		arg.Column4,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AggregateTenantUsageDailyByAPIKeysRow{}
	for rows.Next() {
		var i AggregateTenantUsageDailyByAPIKeysRow
		if err := rows.Scan(
			&i.Day,
			&i.ApiKeyID,
			&i.ApiKeyName,
			&i.ApiKeyPrefix,
			&i.Requests,
			&i.Tokens,
			&i.CostCents,
			&i.CostUsdMicros,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const aggregateUsageByModel = `-- name: AggregateUsageByModel :many
SELECT
    u.model_alias,
    COALESCE(SUM(requests), 0)::bigint AS requests,
    COALESCE(SUM(input_tokens + output_tokens), 0)::bigint AS tokens,
    COALESCE(SUM(cost_cents), 0)::bigint AS cost_cents,
    COALESCE(SUM(cost_usd_micros), 0)::bigint AS cost_usd_micros,
    COALESCE(gr.guardrail_blocks, 0)::bigint AS guardrail_blocks
FROM usage_records u
LEFT JOIN LATERAL (
    SELECT COUNT(*) FILTER (WHERE error_code = 'guardrail_blocked')::bigint AS guardrail_blocks
    FROM requests r
    WHERE r.model_alias = u.model_alias
      AND r.ts >= $1
      AND r.ts < $2
) gr ON TRUE
WHERE u.ts >= $1
  AND u.ts < $2
GROUP BY u.model_alias, gr.guardrail_blocks
ORDER BY cost_cents DESC, requests DESC
LIMIT $3
`

type AggregateUsageByModelParams struct {
	Ts    pgtype.Timestamptz `json:"ts"`
	Ts_2  pgtype.Timestamptz `json:"ts_2"`
	Limit int32              `json:"limit"`
}

type AggregateUsageByModelRow struct {
	ModelAlias      string `json:"model_alias"`
	Requests        int64  `json:"requests"`
	Tokens          int64  `json:"tokens"`
	CostCents       int64  `json:"cost_cents"`
	CostUsdMicros   int64  `json:"cost_usd_micros"`
	GuardrailBlocks int64  `json:"guardrail_blocks"`
}

func (q *Queries) AggregateUsageByModel(ctx context.Context, arg AggregateUsageByModelParams) ([]AggregateUsageByModelRow, error) {
	rows, err := q.db.Query(ctx, aggregateUsageByModel, arg.Ts, arg.Ts_2, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AggregateUsageByModelRow{}
	for rows.Next() {
		var i AggregateUsageByModelRow
		if err := rows.Scan(
			&i.ModelAlias,
			&i.Requests,
			&i.Tokens,
			&i.CostCents,
			&i.CostUsdMicros,
			&i.GuardrailBlocks,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const aggregateUsageByTenant = `-- name: AggregateUsageByTenant :many
SELECT
    u.tenant_id,
    t.name,
    COALESCE(SUM(u.requests), 0)::bigint AS requests,
    COALESCE(SUM(u.input_tokens + u.output_tokens), 0)::bigint AS tokens,
    COALESCE(SUM(u.cost_cents), 0)::bigint AS cost_cents,
    COALESCE(SUM(u.cost_usd_micros), 0)::bigint AS cost_usd_micros,
    COALESCE(gr.guardrail_blocks, 0)::bigint AS guardrail_blocks
FROM usage_records u
JOIN tenants t ON t.id = u.tenant_id
LEFT JOIN LATERAL (
    SELECT COUNT(*) FILTER (WHERE error_code = 'guardrail_blocked')::bigint AS guardrail_blocks
    FROM requests r
    WHERE r.tenant_id = u.tenant_id
      AND r.ts >= $1
      AND r.ts < $2
) gr ON TRUE
WHERE u.ts >= $1
  AND u.ts < $2
GROUP BY u.tenant_id, t.name, gr.guardrail_blocks
ORDER BY cost_cents DESC, requests DESC
LIMIT $3
`

type AggregateUsageByTenantParams struct {
	Ts    pgtype.Timestamptz `json:"ts"`
	Ts_2  pgtype.Timestamptz `json:"ts_2"`
	Limit int32              `json:"limit"`
}

type AggregateUsageByTenantRow struct {
	TenantID        pgtype.UUID `json:"tenant_id"`
	Name            string      `json:"name"`
	Requests        int64       `json:"requests"`
	Tokens          int64       `json:"tokens"`
	CostCents       int64       `json:"cost_cents"`
	CostUsdMicros   int64       `json:"cost_usd_micros"`
	GuardrailBlocks int64       `json:"guardrail_blocks"`
}

func (q *Queries) AggregateUsageByTenant(ctx context.Context, arg AggregateUsageByTenantParams) ([]AggregateUsageByTenantRow, error) {
	rows, err := q.db.Query(ctx, aggregateUsageByTenant, arg.Ts, arg.Ts_2, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AggregateUsageByTenantRow{}
	for rows.Next() {
		var i AggregateUsageByTenantRow
		if err := rows.Scan(
			&i.TenantID,
			&i.Name,
			&i.Requests,
			&i.Tokens,
			&i.CostCents,
			&i.CostUsdMicros,
			&i.GuardrailBlocks,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const aggregateUsageByUser = `-- name: AggregateUsageByUser :many
SELECT
    k.owner_user_id AS user_id,
    u.email,
    u.name,
    COALESCE(SUM(r.requests), 0)::bigint AS requests,
    COALESCE(SUM(r.input_tokens + r.output_tokens), 0)::bigint AS tokens,
    COALESCE(SUM(r.cost_cents), 0)::bigint AS cost_cents,
    COALESCE(SUM(r.cost_usd_micros), 0)::bigint AS cost_usd_micros,
    COALESCE(gr.guardrail_blocks, 0)::bigint AS guardrail_blocks
FROM usage_records r
JOIN api_keys k ON r.api_key_id = k.id
JOIN users u ON u.id = k.owner_user_id
LEFT JOIN LATERAL (
    SELECT COUNT(*) FILTER (WHERE rq.error_code = 'guardrail_blocked')::bigint AS guardrail_blocks
    FROM requests rq
    JOIN api_keys kk ON rq.api_key_id = kk.id
    WHERE kk.owner_user_id = k.owner_user_id
      AND rq.ts >= $1
      AND rq.ts < $2
) gr ON TRUE
WHERE r.ts >= $1
  AND r.ts < $2
GROUP BY k.owner_user_id, u.email, u.name, gr.guardrail_blocks
ORDER BY cost_cents DESC, requests DESC
LIMIT $3
`

type AggregateUsageByUserParams struct {
	Ts    pgtype.Timestamptz `json:"ts"`
	Ts_2  pgtype.Timestamptz `json:"ts_2"`
	Limit int32              `json:"limit"`
}

type AggregateUsageByUserRow struct {
	UserID          pgtype.UUID `json:"user_id"`
	Email           string      `json:"email"`
	Name            string      `json:"name"`
	Requests        int64       `json:"requests"`
	Tokens          int64       `json:"tokens"`
	CostCents       int64       `json:"cost_cents"`
	CostUsdMicros   int64       `json:"cost_usd_micros"`
	GuardrailBlocks int64       `json:"guardrail_blocks"`
}

func (q *Queries) AggregateUsageByUser(ctx context.Context, arg AggregateUsageByUserParams) ([]AggregateUsageByUserRow, error) {
	rows, err := q.db.Query(ctx, aggregateUsageByUser, arg.Ts, arg.Ts_2, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AggregateUsageByUserRow{}
	for rows.Next() {
		var i AggregateUsageByUserRow
		if err := rows.Scan(
			&i.UserID,
			&i.Email,
			&i.Name,
			&i.Requests,
			&i.Tokens,
			&i.CostCents,
			&i.CostUsdMicros,
			&i.GuardrailBlocks,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const aggregateUsageDaily = `-- name: AggregateUsageDaily :many
SELECT
    timezone($4::text, date_trunc('day', ts AT TIME ZONE $4::text))::timestamptz AS day,
    COALESCE(SUM(requests), 0)::bigint AS requests,
    COALESCE(SUM(input_tokens + output_tokens), 0)::bigint AS tokens,
    COALESCE(SUM(cost_cents), 0)::bigint AS cost_cents,
    COALESCE(SUM(cost_usd_micros), 0)::bigint AS cost_usd_micros
FROM usage_records
WHERE ($1::uuid IS NULL OR tenant_id = $1)
  AND ts >= $2
  AND ts < $3
GROUP BY day
ORDER BY day
`

type AggregateUsageDailyParams struct {
	Column1 pgtype.UUID        `json:"column_1"`
	Ts      pgtype.Timestamptz `json:"ts"`
	Ts_2    pgtype.Timestamptz `json:"ts_2"`
	Column4 string             `json:"column_4"`
}

type AggregateUsageDailyRow struct {
	Day           pgtype.Timestamptz `json:"day"`
	Requests      int64              `json:"requests"`
	Tokens        int64              `json:"tokens"`
	CostCents     int64              `json:"cost_cents"`
	CostUsdMicros int64              `json:"cost_usd_micros"`
}

func (q *Queries) AggregateUsageDaily(ctx context.Context, arg AggregateUsageDailyParams) ([]AggregateUsageDailyRow, error) {
	rows, err := q.db.Query(ctx, aggregateUsageDaily,
		arg.Column1,
		arg.Ts,
		arg.Ts_2,
		arg.Column4,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AggregateUsageDailyRow{}
	for rows.Next() {
		var i AggregateUsageDailyRow
		if err := rows.Scan(
			&i.Day,
			&i.Requests,
			&i.Tokens,
			&i.CostCents,
			&i.CostUsdMicros,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const aggregateUsageDailyByModels = `-- name: AggregateUsageDailyByModels :many
SELECT
    model_alias,
    timezone($4::text, date_trunc('day', ts AT TIME ZONE $4::text))::timestamptz AS day,
    COALESCE(SUM(requests), 0)::bigint AS requests,
    COALESCE(SUM(input_tokens + output_tokens), 0)::bigint AS tokens,
    COALESCE(SUM(cost_cents), 0)::bigint AS cost_cents,
    COALESCE(SUM(cost_usd_micros), 0)::bigint AS cost_usd_micros
FROM usage_records
WHERE model_alias = ANY($1::text[])
  AND ts >= $2
  AND ts < $3
  AND (cardinality($5::uuid[]) = 0 OR tenant_id = ANY($5::uuid[]))
GROUP BY model_alias, day
ORDER BY model_alias, day
`

type AggregateUsageDailyByModelsParams struct {
	Column1 []string           `json:"column_1"`
	Ts      pgtype.Timestamptz `json:"ts"`
	Ts_2    pgtype.Timestamptz `json:"ts_2"`
	Column4 string             `json:"column_4"`
	Column5 []pgtype.UUID      `json:"column_5"`
}

type AggregateUsageDailyByModelsRow struct {
	ModelAlias    string             `json:"model_alias"`
	Day           pgtype.Timestamptz `json:"day"`
	Requests      int64              `json:"requests"`
	Tokens        int64              `json:"tokens"`
	CostCents     int64              `json:"cost_cents"`
	CostUsdMicros int64              `json:"cost_usd_micros"`
}

func (q *Queries) AggregateUsageDailyByModels(ctx context.Context, arg AggregateUsageDailyByModelsParams) ([]AggregateUsageDailyByModelsRow, error) {
	rows, err := q.db.Query(ctx, aggregateUsageDailyByModels,
		arg.Column1,
		arg.Ts,
		arg.Ts_2,
		arg.Column4,
		arg.Column5,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AggregateUsageDailyByModelsRow{}
	for rows.Next() {
		var i AggregateUsageDailyByModelsRow
		if err := rows.Scan(
			&i.ModelAlias,
			&i.Day,
			&i.Requests,
			&i.Tokens,
			&i.CostCents,
			&i.CostUsdMicros,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const aggregateUsageDailyByTenants = `-- name: AggregateUsageDailyByTenants :many
SELECT
    tenant_id,
    timezone($4::text, date_trunc('day', ts AT TIME ZONE $4::text))::timestamptz AS day,
    COALESCE(SUM(requests), 0)::bigint AS requests,
    COALESCE(SUM(input_tokens + output_tokens), 0)::bigint AS tokens,
    COALESCE(SUM(cost_cents), 0)::bigint AS cost_cents,
    COALESCE(SUM(cost_usd_micros), 0)::bigint AS cost_usd_micros
FROM usage_records
WHERE tenant_id = ANY($1::uuid[])
  AND ts >= $2
  AND ts < $3
GROUP BY tenant_id, day
ORDER BY tenant_id, day
`

type AggregateUsageDailyByTenantsParams struct {
	Column1 []pgtype.UUID      `json:"column_1"`
	Ts      pgtype.Timestamptz `json:"ts"`
	Ts_2    pgtype.Timestamptz `json:"ts_2"`
	Column4 string             `json:"column_4"`
}

type AggregateUsageDailyByTenantsRow struct {
	TenantID      pgtype.UUID        `json:"tenant_id"`
	Day           pgtype.Timestamptz `json:"day"`
	Requests      int64              `json:"requests"`
	Tokens        int64              `json:"tokens"`
	CostCents     int64              `json:"cost_cents"`
	CostUsdMicros int64              `json:"cost_usd_micros"`
}

func (q *Queries) AggregateUsageDailyByTenants(ctx context.Context, arg AggregateUsageDailyByTenantsParams) ([]AggregateUsageDailyByTenantsRow, error) {
	rows, err := q.db.Query(ctx, aggregateUsageDailyByTenants,
		arg.Column1,
		arg.Ts,
		arg.Ts_2,
		arg.Column4,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AggregateUsageDailyByTenantsRow{}
	for rows.Next() {
		var i AggregateUsageDailyByTenantsRow
		if err := rows.Scan(
			&i.TenantID,
			&i.Day,
			&i.Requests,
			&i.Tokens,
			&i.CostCents,
			&i.CostUsdMicros,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const aggregateUsageDailyByUsers = `-- name: AggregateUsageDailyByUsers :many
SELECT
    k.owner_user_id AS user_id,
    timezone($4::text, date_trunc('day', r.ts AT TIME ZONE $4::text))::timestamptz AS day,
    COALESCE(SUM(r.requests), 0)::bigint AS requests,
    COALESCE(SUM(r.input_tokens + r.output_tokens), 0)::bigint AS tokens,
    COALESCE(SUM(r.cost_cents), 0)::bigint AS cost_cents,
    COALESCE(SUM(r.cost_usd_micros), 0)::bigint AS cost_usd_micros
FROM usage_records r
JOIN api_keys k ON r.api_key_id = k.id
WHERE k.owner_user_id = ANY($1::uuid[])
  AND r.ts >= $2
  AND r.ts < $3
GROUP BY k.owner_user_id, day
ORDER BY k.owner_user_id, day
`

type AggregateUsageDailyByUsersParams struct {
	Column1 []pgtype.UUID      `json:"column_1"`
	Ts      pgtype.Timestamptz `json:"ts"`
	Ts_2    pgtype.Timestamptz `json:"ts_2"`
	Column4 string             `json:"column_4"`
}

type AggregateUsageDailyByUsersRow struct {
	UserID        pgtype.UUID        `json:"user_id"`
	Day           pgtype.Timestamptz `json:"day"`
	Requests      int64              `json:"requests"`
	Tokens        int64              `json:"tokens"`
	CostCents     int64              `json:"cost_cents"`
	CostUsdMicros int64              `json:"cost_usd_micros"`
}

func (q *Queries) AggregateUsageDailyByUsers(ctx context.Context, arg AggregateUsageDailyByUsersParams) ([]AggregateUsageDailyByUsersRow, error) {
	rows, err := q.db.Query(ctx, aggregateUsageDailyByUsers,
		arg.Column1,
		arg.Ts,
		arg.Ts_2,
		arg.Column4,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AggregateUsageDailyByUsersRow{}
	for rows.Next() {
		var i AggregateUsageDailyByUsersRow
		if err := rows.Scan(
			&i.UserID,
			&i.Day,
			&i.Requests,
			&i.Tokens,
			&i.CostCents,
			&i.CostUsdMicros,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const aggregateUsageDailyForUserTenant = `-- name: AggregateUsageDailyForUserTenant :many
SELECT
    timezone($5::text, date_trunc('day', u.ts AT TIME ZONE $5::text))::timestamptz AS day,
    COALESCE(SUM(u.requests), 0)::bigint AS requests,
    COALESCE(SUM(u.input_tokens + u.output_tokens), 0)::bigint AS tokens,
    COALESCE(SUM(u.cost_cents), 0)::bigint AS cost_cents,
    COALESCE(SUM(u.cost_usd_micros), 0)::bigint AS cost_usd_micros
FROM usage_records u
JOIN api_keys k ON u.api_key_id = k.id
WHERE k.owner_user_id = $1
  AND u.tenant_id = $2
  AND u.ts >= $3
  AND u.ts < $4
GROUP BY day
ORDER BY day
`

type AggregateUsageDailyForUserTenantParams struct {
	OwnerUserID pgtype.UUID        `json:"owner_user_id"`
	TenantID    pgtype.UUID        `json:"tenant_id"`
	Ts          pgtype.Timestamptz `json:"ts"`
	Ts_2        pgtype.Timestamptz `json:"ts_2"`
	Column5     string             `json:"column_5"`
}

type AggregateUsageDailyForUserTenantRow struct {
	Day           pgtype.Timestamptz `json:"day"`
	Requests      int64              `json:"requests"`
	Tokens        int64              `json:"tokens"`
	CostCents     int64              `json:"cost_cents"`
	CostUsdMicros int64              `json:"cost_usd_micros"`
}

func (q *Queries) AggregateUsageDailyForUserTenant(ctx context.Context, arg AggregateUsageDailyForUserTenantParams) ([]AggregateUsageDailyForUserTenantRow, error) {
	rows, err := q.db.Query(ctx, aggregateUsageDailyForUserTenant,
		arg.OwnerUserID,
		arg.TenantID,
		arg.Ts,
		arg.Ts_2,
		arg.Column5,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AggregateUsageDailyForUserTenantRow{}
	for rows.Next() {
		var i AggregateUsageDailyForUserTenantRow
		if err := rows.Scan(
			&i.Day,
			&i.Requests,
			&i.Tokens,
			&i.CostCents,
			&i.CostUsdMicros,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const aggregateUserUsageDailyByTenants = `-- name: AggregateUserUsageDailyByTenants :many
SELECT
    timezone($4::text, date_trunc('day', r.ts AT TIME ZONE $4::text))::timestamptz AS day,
    r.tenant_id,
    COALESCE(t.name, '') AS tenant_name,
    COALESCE(SUM(r.requests), 0)::bigint AS requests,
    COALESCE(SUM(r.input_tokens + r.output_tokens), 0)::bigint AS tokens,
    COALESCE(SUM(r.cost_cents), 0)::bigint AS cost_cents,
    COALESCE(SUM(r.cost_usd_micros), 0)::bigint AS cost_usd_micros
FROM usage_records r
JOIN api_keys k ON k.id = r.api_key_id
LEFT JOIN tenants t ON t.id = r.tenant_id
WHERE k.owner_user_id = $1
  AND r.ts >= $2
  AND r.ts < $3
GROUP BY day, r.tenant_id, t.name
ORDER BY day, tenant_name
`

type AggregateUserUsageDailyByTenantsParams struct {
	OwnerUserID pgtype.UUID        `json:"owner_user_id"`
	Ts          pgtype.Timestamptz `json:"ts"`
	Ts_2        pgtype.Timestamptz `json:"ts_2"`
	Column4     string             `json:"column_4"`
}

type AggregateUserUsageDailyByTenantsRow struct {
	Day           pgtype.Timestamptz `json:"day"`
	TenantID      pgtype.UUID        `json:"tenant_id"`
	TenantName    string             `json:"tenant_name"`
	Requests      int64              `json:"requests"`
	Tokens        int64              `json:"tokens"`
	CostCents     int64              `json:"cost_cents"`
	CostUsdMicros int64              `json:"cost_usd_micros"`
}

func (q *Queries) AggregateUserUsageDailyByTenants(ctx context.Context, arg AggregateUserUsageDailyByTenantsParams) ([]AggregateUserUsageDailyByTenantsRow, error) {
	rows, err := q.db.Query(ctx, aggregateUserUsageDailyByTenants,
		arg.OwnerUserID,
		arg.Ts,
		arg.Ts_2,
		arg.Column4,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AggregateUserUsageDailyByTenantsRow{}
	for rows.Next() {
		var i AggregateUserUsageDailyByTenantsRow
		if err := rows.Scan(
			&i.Day,
			&i.TenantID,
			&i.TenantName,
			&i.Requests,
			&i.Tokens,
			&i.CostCents,
			&i.CostUsdMicros,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const countGuardrailRequests = `-- name: CountGuardrailRequests :one
SELECT
    COALESCE(COUNT(*) FILTER (WHERE error_code = 'guardrail_blocked'), 0)::bigint AS guardrail_blocks
FROM requests
WHERE ($1::uuid IS NULL OR tenant_id = $1)
  AND ts >= $2
  AND ts < $3
`

type CountGuardrailRequestsParams struct {
	Column1 pgtype.UUID        `json:"column_1"`
	Ts      pgtype.Timestamptz `json:"ts"`
	Ts_2    pgtype.Timestamptz `json:"ts_2"`
}

func (q *Queries) CountGuardrailRequests(ctx context.Context, arg CountGuardrailRequestsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countGuardrailRequests, arg.Column1, arg.Ts, arg.Ts_2)
	var guardrail_blocks int64
	err := row.Scan(&guardrail_blocks)
	return guardrail_blocks, err
}

const insertUsageRecord = `-- name: InsertUsageRecord :one
INSERT INTO usage_records (
    tenant_id,
    api_key_id,
    ts,
    model_alias,
    provider,
    input_tokens,
    output_tokens,
    requests,
    cost_cents,
    cost_usd_micros
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
RETURNING id, tenant_id, api_key_id, ts, model_alias, provider, input_tokens, output_tokens, requests, cost_cents, cost_usd_micros
`

type InsertUsageRecordParams struct {
	TenantID      pgtype.UUID        `json:"tenant_id"`
	ApiKeyID      pgtype.UUID        `json:"api_key_id"`
	Ts            pgtype.Timestamptz `json:"ts"`
	ModelAlias    string             `json:"model_alias"`
	Provider      string             `json:"provider"`
	InputTokens   int64              `json:"input_tokens"`
	OutputTokens  int64              `json:"output_tokens"`
	Requests      int64              `json:"requests"`
	CostCents     int64              `json:"cost_cents"`
	CostUsdMicros int64              `json:"cost_usd_micros"`
}

func (q *Queries) InsertUsageRecord(ctx context.Context, arg InsertUsageRecordParams) (UsageRecord, error) {
	row := q.db.QueryRow(ctx, insertUsageRecord,
		arg.TenantID,
		arg.ApiKeyID,
		arg.Ts,
		arg.ModelAlias,
		arg.Provider,
		arg.InputTokens,
		arg.OutputTokens,
		arg.Requests,
		arg.CostCents,
		arg.CostUsdMicros,
	)
	var i UsageRecord
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.ApiKeyID,
		&i.Ts,
		&i.ModelAlias,
		&i.Provider,
		&i.InputTokens,
		&i.OutputTokens,
		&i.Requests,
		&i.CostCents,
		&i.CostUsdMicros,
	)
	return i, err
}

const listUsageRecords = `-- name: ListUsageRecords :many
SELECT id, tenant_id, api_key_id, ts, model_alias, provider, input_tokens, output_tokens, requests, cost_cents, cost_usd_micros
FROM usage_records
WHERE tenant_id = $1
  AND ts >= $2
  AND ts < $3
ORDER BY ts DESC
LIMIT $4 OFFSET $5
`

type ListUsageRecordsParams struct {
	TenantID pgtype.UUID        `json:"tenant_id"`
	Ts       pgtype.Timestamptz `json:"ts"`
	Ts_2     pgtype.Timestamptz `json:"ts_2"`
	Limit    int32              `json:"limit"`
	Offset   int32              `json:"offset"`
}

func (q *Queries) ListUsageRecords(ctx context.Context, arg ListUsageRecordsParams) ([]UsageRecord, error) {
	rows, err := q.db.Query(ctx, listUsageRecords,
		arg.TenantID,
		arg.Ts,
		arg.Ts_2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []UsageRecord{}
	for rows.Next() {
		var i UsageRecord
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.ApiKeyID,
			&i.Ts,
			&i.ModelAlias,
			&i.Provider,
			&i.InputTokens,
			&i.OutputTokens,
			&i.Requests,
			&i.CostCents,
			&i.CostUsdMicros,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserOwnedTenants = `-- name: ListUserOwnedTenants :many
SELECT DISTINCT
    tm.tenant_id,
    t.name,
    tm.role,
    t.status
FROM tenant_memberships tm
JOIN tenants t ON t.id = tm.tenant_id
WHERE tm.user_id = $1
  AND t.kind <> 'personal'
  AND EXISTS (
    SELECT 1
    FROM api_keys k
    WHERE k.owner_user_id = $1
      AND k.tenant_id = tm.tenant_id
  )
ORDER BY t.name
`

type ListUserOwnedTenantsRow struct {
	TenantID pgtype.UUID    `json:"tenant_id"`
	Name     string         `json:"name"`
	Role     MembershipRole `json:"role"`
	Status   TenantStatus   `json:"status"`
}

func (q *Queries) ListUserOwnedTenants(ctx context.Context, userID pgtype.UUID) ([]ListUserOwnedTenantsRow, error) {
	rows, err := q.db.Query(ctx, listUserOwnedTenants, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListUserOwnedTenantsRow{}
	for rows.Next() {
		var i ListUserOwnedTenantsRow
		if err := rows.Scan(
			&i.TenantID,
			&i.Name,
			&i.Role,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const sumUsage = `-- name: SumUsage :one
SELECT
    COALESCE(SUM(requests), 0)::bigint AS total_requests,
    COALESCE(SUM(input_tokens + output_tokens), 0)::bigint AS total_tokens,
    COALESCE(SUM(cost_cents), 0)::bigint AS total_cost_cents,
    COALESCE(SUM(cost_usd_micros), 0)::bigint AS total_cost_usd_micros
FROM usage_records
WHERE ($1::uuid IS NULL OR tenant_id = $1)
  AND ts >= $2
  AND ts < $3
`

type SumUsageParams struct {
	Column1 pgtype.UUID        `json:"column_1"`
	Ts      pgtype.Timestamptz `json:"ts"`
	Ts_2    pgtype.Timestamptz `json:"ts_2"`
}

type SumUsageRow struct {
	TotalRequests      int64 `json:"total_requests"`
	TotalTokens        int64 `json:"total_tokens"`
	TotalCostCents     int64 `json:"total_cost_cents"`
	TotalCostUsdMicros int64 `json:"total_cost_usd_micros"`
}

func (q *Queries) SumUsage(ctx context.Context, arg SumUsageParams) (SumUsageRow, error) {
	row := q.db.QueryRow(ctx, sumUsage, arg.Column1, arg.Ts, arg.Ts_2)
	var i SumUsageRow
	err := row.Scan(
		&i.TotalRequests,
		&i.TotalTokens,
		&i.TotalCostCents,
		&i.TotalCostUsdMicros,
	)
	return i, err
}

const sumUsageByModels = `-- name: SumUsageByModels :many
SELECT
    model_alias,
    COALESCE(SUM(requests), 0)::bigint AS total_requests,
    COALESCE(SUM(input_tokens + output_tokens), 0)::bigint AS total_tokens,
    COALESCE(SUM(cost_cents), 0)::bigint AS total_cost_cents,
    COALESCE(SUM(cost_usd_micros), 0)::bigint AS total_cost_usd_micros
FROM usage_records
WHERE model_alias = ANY($1::text[])
  AND ts >= $2
  AND ts < $3
  AND (cardinality($4::uuid[]) = 0 OR tenant_id = ANY($4::uuid[]))
GROUP BY model_alias
`

type SumUsageByModelsParams struct {
	Column1 []string           `json:"column_1"`
	Ts      pgtype.Timestamptz `json:"ts"`
	Ts_2    pgtype.Timestamptz `json:"ts_2"`
	Column4 []pgtype.UUID      `json:"column_4"`
}

type SumUsageByModelsRow struct {
	ModelAlias         string `json:"model_alias"`
	TotalRequests      int64  `json:"total_requests"`
	TotalTokens        int64  `json:"total_tokens"`
	TotalCostCents     int64  `json:"total_cost_cents"`
	TotalCostUsdMicros int64  `json:"total_cost_usd_micros"`
}

func (q *Queries) SumUsageByModels(ctx context.Context, arg SumUsageByModelsParams) ([]SumUsageByModelsRow, error) {
	rows, err := q.db.Query(ctx, sumUsageByModels,
		arg.Column1,
		arg.Ts,
		arg.Ts_2,
		arg.Column4,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SumUsageByModelsRow{}
	for rows.Next() {
		var i SumUsageByModelsRow
		if err := rows.Scan(
			&i.ModelAlias,
			&i.TotalRequests,
			&i.TotalTokens,
			&i.TotalCostCents,
			&i.TotalCostUsdMicros,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const sumUsageByTenants = `-- name: SumUsageByTenants :many
SELECT
    tenant_id,
    COALESCE(SUM(requests), 0)::bigint AS total_requests,
    COALESCE(SUM(input_tokens + output_tokens), 0)::bigint AS total_tokens,
    COALESCE(SUM(cost_cents), 0)::bigint AS total_cost_cents,
    COALESCE(SUM(cost_usd_micros), 0)::bigint AS total_cost_usd_micros
FROM usage_records
WHERE tenant_id = ANY($1::uuid[])
  AND ts >= $2
  AND ts < $3
GROUP BY tenant_id
`

type SumUsageByTenantsParams struct {
	Column1 []pgtype.UUID      `json:"column_1"`
	Ts      pgtype.Timestamptz `json:"ts"`
	Ts_2    pgtype.Timestamptz `json:"ts_2"`
}

type SumUsageByTenantsRow struct {
	TenantID           pgtype.UUID `json:"tenant_id"`
	TotalRequests      int64       `json:"total_requests"`
	TotalTokens        int64       `json:"total_tokens"`
	TotalCostCents     int64       `json:"total_cost_cents"`
	TotalCostUsdMicros int64       `json:"total_cost_usd_micros"`
}

func (q *Queries) SumUsageByTenants(ctx context.Context, arg SumUsageByTenantsParams) ([]SumUsageByTenantsRow, error) {
	rows, err := q.db.Query(ctx, sumUsageByTenants, arg.Column1, arg.Ts, arg.Ts_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SumUsageByTenantsRow{}
	for rows.Next() {
		var i SumUsageByTenantsRow
		if err := rows.Scan(
			&i.TenantID,
			&i.TotalRequests,
			&i.TotalTokens,
			&i.TotalCostCents,
			&i.TotalCostUsdMicros,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const sumUsageByUsers = `-- name: SumUsageByUsers :many
SELECT
    k.owner_user_id AS user_id,
    COALESCE(SUM(r.requests), 0)::bigint AS total_requests,
    COALESCE(SUM(r.input_tokens + r.output_tokens), 0)::bigint AS total_tokens,
    COALESCE(SUM(r.cost_cents), 0)::bigint AS total_cost_cents,
    COALESCE(SUM(r.cost_usd_micros), 0)::bigint AS total_cost_usd_micros
FROM usage_records r
JOIN api_keys k ON r.api_key_id = k.id
WHERE k.owner_user_id = ANY($1::uuid[])
  AND r.ts >= $2
  AND r.ts < $3
GROUP BY k.owner_user_id
`

type SumUsageByUsersParams struct {
	Column1 []pgtype.UUID      `json:"column_1"`
	Ts      pgtype.Timestamptz `json:"ts"`
	Ts_2    pgtype.Timestamptz `json:"ts_2"`
}

type SumUsageByUsersRow struct {
	UserID             pgtype.UUID `json:"user_id"`
	TotalRequests      int64       `json:"total_requests"`
	TotalTokens        int64       `json:"total_tokens"`
	TotalCostCents     int64       `json:"total_cost_cents"`
	TotalCostUsdMicros int64       `json:"total_cost_usd_micros"`
}

func (q *Queries) SumUsageByUsers(ctx context.Context, arg SumUsageByUsersParams) ([]SumUsageByUsersRow, error) {
	rows, err := q.db.Query(ctx, sumUsageByUsers, arg.Column1, arg.Ts, arg.Ts_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SumUsageByUsersRow{}
	for rows.Next() {
		var i SumUsageByUsersRow
		if err := rows.Scan(
			&i.UserID,
			&i.TotalRequests,
			&i.TotalTokens,
			&i.TotalCostCents,
			&i.TotalCostUsdMicros,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const sumUsageForAPIKey = `-- name: SumUsageForAPIKey :one
SELECT
    COALESCE(SUM(requests), 0)::bigint AS total_requests,
    COALESCE(SUM(input_tokens + output_tokens), 0)::bigint AS total_tokens,
    COALESCE(SUM(cost_cents), 0)::bigint AS total_cost_cents,
    COALESCE(SUM(cost_usd_micros), 0)::bigint AS total_cost_usd_micros
FROM usage_records
WHERE api_key_id = $1
  AND ts >= $2
  AND ts < $3
`

type SumUsageForAPIKeyParams struct {
	ApiKeyID pgtype.UUID        `json:"api_key_id"`
	Ts       pgtype.Timestamptz `json:"ts"`
	Ts_2     pgtype.Timestamptz `json:"ts_2"`
}

type SumUsageForAPIKeyRow struct {
	TotalRequests      int64 `json:"total_requests"`
	TotalTokens        int64 `json:"total_tokens"`
	TotalCostCents     int64 `json:"total_cost_cents"`
	TotalCostUsdMicros int64 `json:"total_cost_usd_micros"`
}

func (q *Queries) SumUsageForAPIKey(ctx context.Context, arg SumUsageForAPIKeyParams) (SumUsageForAPIKeyRow, error) {
	row := q.db.QueryRow(ctx, sumUsageForAPIKey, arg.ApiKeyID, arg.Ts, arg.Ts_2)
	var i SumUsageForAPIKeyRow
	err := row.Scan(
		&i.TotalRequests,
		&i.TotalTokens,
		&i.TotalCostCents,
		&i.TotalCostUsdMicros,
	)
	return i, err
}

const sumUsageForTenant = `-- name: SumUsageForTenant :one
SELECT
    COALESCE(SUM(input_tokens), 0) AS total_input_tokens,
    COALESCE(SUM(output_tokens), 0) AS total_output_tokens,
    COALESCE(SUM(requests), 0) AS total_requests,
    COALESCE(SUM(cost_cents), 0)::bigint AS total_cost_cents,
    COALESCE(SUM(cost_usd_micros), 0)::bigint AS total_cost_usd_micros
FROM usage_records
WHERE tenant_id = $1
  AND ts >= $2
  AND ts < $3
`

type SumUsageForTenantParams struct {
	TenantID pgtype.UUID        `json:"tenant_id"`
	Ts       pgtype.Timestamptz `json:"ts"`
	Ts_2     pgtype.Timestamptz `json:"ts_2"`
}

type SumUsageForTenantRow struct {
	TotalInputTokens   interface{} `json:"total_input_tokens"`
	TotalOutputTokens  interface{} `json:"total_output_tokens"`
	TotalRequests      interface{} `json:"total_requests"`
	TotalCostCents     int64       `json:"total_cost_cents"`
	TotalCostUsdMicros int64       `json:"total_cost_usd_micros"`
}

func (q *Queries) SumUsageForTenant(ctx context.Context, arg SumUsageForTenantParams) (SumUsageForTenantRow, error) {
	row := q.db.QueryRow(ctx, sumUsageForTenant, arg.TenantID, arg.Ts, arg.Ts_2)
	var i SumUsageForTenantRow
	err := row.Scan(
		&i.TotalInputTokens,
		&i.TotalOutputTokens,
		&i.TotalRequests,
		&i.TotalCostCents,
		&i.TotalCostUsdMicros,
	)
	return i, err
}

const sumUsageForUserTenant = `-- name: SumUsageForUserTenant :one
SELECT
    COALESCE(SUM(u.requests), 0)::bigint AS total_requests,
    COALESCE(SUM(u.input_tokens + u.output_tokens), 0)::bigint AS total_tokens,
    COALESCE(SUM(u.cost_cents), 0)::bigint AS total_cost_cents,
    COALESCE(SUM(u.cost_usd_micros), 0)::bigint AS total_cost_usd_micros
FROM usage_records u
JOIN api_keys k ON u.api_key_id = k.id
WHERE k.owner_user_id = $1
  AND u.tenant_id = $2
  AND u.ts >= $3
  AND u.ts < $4
`

type SumUsageForUserTenantParams struct {
	OwnerUserID pgtype.UUID        `json:"owner_user_id"`
	TenantID    pgtype.UUID        `json:"tenant_id"`
	Ts          pgtype.Timestamptz `json:"ts"`
	Ts_2        pgtype.Timestamptz `json:"ts_2"`
}

type SumUsageForUserTenantRow struct {
	TotalRequests      int64 `json:"total_requests"`
	TotalTokens        int64 `json:"total_tokens"`
	TotalCostCents     int64 `json:"total_cost_cents"`
	TotalCostUsdMicros int64 `json:"total_cost_usd_micros"`
}

func (q *Queries) SumUsageForUserTenant(ctx context.Context, arg SumUsageForUserTenantParams) (SumUsageForUserTenantRow, error) {
	row := q.db.QueryRow(ctx, sumUsageForUserTenant,
		arg.OwnerUserID,
		arg.TenantID,
		arg.Ts,
		arg.Ts_2,
	)
	var i SumUsageForUserTenantRow
	err := row.Scan(
		&i.TotalRequests,
		&i.TotalTokens,
		&i.TotalCostCents,
		&i.TotalCostUsdMicros,
	)
	return i, err
}
