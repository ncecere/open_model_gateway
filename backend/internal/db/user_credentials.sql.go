// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: user_credentials.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getCredentialBySubject = `-- name: GetCredentialBySubject :one
SELECT id, user_id, provider, issuer, subject, password_hash, metadata, created_at, updated_at
FROM user_credentials
WHERE provider = $1 AND issuer = $2 AND subject = $3
`

type GetCredentialBySubjectParams struct {
	Provider string `json:"provider"`
	Issuer   string `json:"issuer"`
	Subject  string `json:"subject"`
}

func (q *Queries) GetCredentialBySubject(ctx context.Context, arg GetCredentialBySubjectParams) (UserCredential, error) {
	row := q.db.QueryRow(ctx, getCredentialBySubject, arg.Provider, arg.Issuer, arg.Subject)
	var i UserCredential
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Provider,
		&i.Issuer,
		&i.Subject,
		&i.PasswordHash,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCredentialByUserAndProvider = `-- name: GetCredentialByUserAndProvider :one
SELECT id, user_id, provider, issuer, subject, password_hash, metadata, created_at, updated_at
FROM user_credentials
WHERE user_id = $1 AND provider = $2 AND issuer = $3
`

type GetCredentialByUserAndProviderParams struct {
	UserID   pgtype.UUID `json:"user_id"`
	Provider string      `json:"provider"`
	Issuer   string      `json:"issuer"`
}

func (q *Queries) GetCredentialByUserAndProvider(ctx context.Context, arg GetCredentialByUserAndProviderParams) (UserCredential, error) {
	row := q.db.QueryRow(ctx, getCredentialByUserAndProvider, arg.UserID, arg.Provider, arg.Issuer)
	var i UserCredential
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Provider,
		&i.Issuer,
		&i.Subject,
		&i.PasswordHash,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listCredentialsForUser = `-- name: ListCredentialsForUser :many
SELECT id, user_id, provider, issuer, subject, password_hash, metadata, created_at, updated_at
FROM user_credentials
WHERE user_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListCredentialsForUser(ctx context.Context, userID pgtype.UUID) ([]UserCredential, error) {
	rows, err := q.db.Query(ctx, listCredentialsForUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []UserCredential{}
	for rows.Next() {
		var i UserCredential
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Provider,
			&i.Issuer,
			&i.Subject,
			&i.PasswordHash,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertCredential = `-- name: UpsertCredential :one
INSERT INTO user_credentials (
    user_id,
    provider,
    issuer,
    subject,
    password_hash,
    metadata
)
VALUES ($1, $2, $3, $4, $5, $6)
ON CONFLICT (provider, issuer, subject)
DO UPDATE SET
    user_id = EXCLUDED.user_id,
    password_hash = COALESCE(EXCLUDED.password_hash, user_credentials.password_hash),
    metadata = EXCLUDED.metadata,
    updated_at = NOW()
RETURNING id, user_id, provider, issuer, subject, password_hash, metadata, created_at, updated_at
`

type UpsertCredentialParams struct {
	UserID       pgtype.UUID `json:"user_id"`
	Provider     string      `json:"provider"`
	Issuer       string      `json:"issuer"`
	Subject      string      `json:"subject"`
	PasswordHash pgtype.Text `json:"password_hash"`
	Metadata     []byte      `json:"metadata"`
}

func (q *Queries) UpsertCredential(ctx context.Context, arg UpsertCredentialParams) (UserCredential, error) {
	row := q.db.QueryRow(ctx, upsertCredential,
		arg.UserID,
		arg.Provider,
		arg.Issuer,
		arg.Subject,
		arg.PasswordHash,
		arg.Metadata,
	)
	var i UserCredential
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Provider,
		&i.Issuer,
		&i.Subject,
		&i.PasswordHash,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
